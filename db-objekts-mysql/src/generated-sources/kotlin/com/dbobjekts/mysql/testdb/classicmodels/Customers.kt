package com.dbobjekts.mysql.testdb.classicmodels

import com.dbobjekts.api.AnyColumn
import com.dbobjekts.api.TableRowData
import com.dbobjekts.metadata.Table
import com.dbobjekts.metadata.column.LongColumn
import com.dbobjekts.metadata.column.NullableBigDecimalColumn
import com.dbobjekts.metadata.column.NullableVarcharColumn
import com.dbobjekts.metadata.column.OptionalForeignKeyLongColumn
import com.dbobjekts.metadata.column.VarcharColumn
import com.dbobjekts.statement.WriteQueryAccessors
import com.dbobjekts.statement.insert.InsertBuilderBase
import com.dbobjekts.statement.update.HasUpdateBuilder
import com.dbobjekts.statement.update.UpdateBuilderBase

/**           
 * Auto-generated metadata object for db table classicmodels.customers.
 *
 * Do not edit this file manually! Always use [com.dbobjekts.codegen.CodeGenerator] when the metadata model is no longer in sync with the database.           
 *
 * Primary keys: customerNumber
 *
 * Foreign keys to: 
 * References by: classicmodels.employees,classicmodels.orders,classicmodels.payments
 */
object Customers:Table<CustomersRow>("customers"), HasUpdateBuilder<CustomersUpdateBuilder, CustomersInsertBuilder> {
    /**
     * Represents db column classicmodels.customers.customerNumber
     */
    val customerNumber = LongColumn(this, "customerNumber")
    /**
     * Represents db column classicmodels.customers.customerName
     */
    val customerName = VarcharColumn(this, "customerName")
    /**
     * Represents db column classicmodels.customers.contactLastName
     */
    val contactLastName = VarcharColumn(this, "contactLastName")
    /**
     * Represents db column classicmodels.customers.contactFirstName
     */
    val contactFirstName = VarcharColumn(this, "contactFirstName")
    /**
     * Represents db column classicmodels.customers.phone
     */
    val phone = VarcharColumn(this, "phone")
    /**
     * Represents db column classicmodels.customers.addressLine1
     */
    val addressLine1 = VarcharColumn(this, "addressLine1")
    /**
     * Represents db column classicmodels.customers.addressLine2
     */
    val addressLine2 = NullableVarcharColumn(this, "addressLine2")
    /**
     * Represents db column classicmodels.customers.city
     */
    val city = VarcharColumn(this, "city")
    /**
     * Represents db column classicmodels.customers.state
     */
    val state = NullableVarcharColumn(this, "state")
    /**
     * Represents db column classicmodels.customers.postalCode
     */
    val postalCode = NullableVarcharColumn(this, "postalCode")
    /**
     * Represents db column classicmodels.customers.country
     */
    val country = VarcharColumn(this, "country")
    /**
     * Represents db column classicmodels.customers.salesRepEmployeeNumber
     *
     * Foreign key to classicmodels.employees.employeeNumber
     */
    val salesRepEmployeeNumber = OptionalForeignKeyLongColumn(this, "salesRepEmployeeNumber", Employees.employeeNumber)
    /**
     * Represents db column classicmodels.customers.creditLimit
     */
    val creditLimit = NullableBigDecimalColumn(this, "creditLimit")
    override val columns: List<AnyColumn> = listOf(customerNumber,customerName,contactLastName,contactFirstName,phone,addressLine1,addressLine2,city,state,postalCode,country,salesRepEmployeeNumber,creditLimit)
    override fun toValue(values: List<Any?>) = CustomersRow(values[0] as Long,values[1] as String,values[2] as String,values[3] as String,values[4] as String,values[5] as String,values[6] as String?,values[7] as String,values[8] as String?,values[9] as String?,values[10] as String,values[11] as Long?,values[12] as java.math.BigDecimal?)
    override fun metadata(): WriteQueryAccessors<CustomersUpdateBuilder, CustomersInsertBuilder> = WriteQueryAccessors(CustomersUpdateBuilder(), CustomersInsertBuilder())
}

class CustomersUpdateBuilder() : UpdateBuilderBase(Customers) {
    fun customerNumber(value: Long): CustomersUpdateBuilder = put(Customers.customerNumber, value)
    fun customerName(value: String): CustomersUpdateBuilder = put(Customers.customerName, value)
    fun contactLastName(value: String): CustomersUpdateBuilder = put(Customers.contactLastName, value)
    fun contactFirstName(value: String): CustomersUpdateBuilder = put(Customers.contactFirstName, value)
    fun phone(value: String): CustomersUpdateBuilder = put(Customers.phone, value)
    fun addressLine1(value: String): CustomersUpdateBuilder = put(Customers.addressLine1, value)
    fun addressLine2(value: String?): CustomersUpdateBuilder = put(Customers.addressLine2, value)
    fun city(value: String): CustomersUpdateBuilder = put(Customers.city, value)
    fun state(value: String?): CustomersUpdateBuilder = put(Customers.state, value)
    fun postalCode(value: String?): CustomersUpdateBuilder = put(Customers.postalCode, value)
    fun country(value: String): CustomersUpdateBuilder = put(Customers.country, value)
    fun salesRepEmployeeNumber(value: Long?): CustomersUpdateBuilder = put(Customers.salesRepEmployeeNumber, value)
    fun creditLimit(value: java.math.BigDecimal?): CustomersUpdateBuilder = put(Customers.creditLimit, value)
    
    /**
     * FOR INTERNAL USE ONLY
     */
    override fun updateRow(rowData: TableRowData<*, *>): Long {
      rowData as CustomersRow
      add(Customers.customerNumber, rowData.customerNumber)
      add(Customers.customerName, rowData.customerName)
      add(Customers.contactLastName, rowData.contactLastName)
      add(Customers.contactFirstName, rowData.contactFirstName)
      add(Customers.phone, rowData.phone)
      add(Customers.addressLine1, rowData.addressLine1)
      add(Customers.addressLine2, rowData.addressLine2)
      add(Customers.city, rowData.city)
      add(Customers.state, rowData.state)
      add(Customers.postalCode, rowData.postalCode)
      add(Customers.country, rowData.country)
      add(Customers.salesRepEmployeeNumber, rowData.salesRepEmployeeNumber)
      add(Customers.creditLimit, rowData.creditLimit)
      return where(Customers.customerNumber.eq(rowData.customerNumber))
    }    
        
}

class CustomersInsertBuilder():InsertBuilderBase(){
    fun customerNumber(value: Long): CustomersInsertBuilder = put(Customers.customerNumber, value)
    fun customerName(value: String): CustomersInsertBuilder = put(Customers.customerName, value)
    fun contactLastName(value: String): CustomersInsertBuilder = put(Customers.contactLastName, value)
    fun contactFirstName(value: String): CustomersInsertBuilder = put(Customers.contactFirstName, value)
    fun phone(value: String): CustomersInsertBuilder = put(Customers.phone, value)
    fun addressLine1(value: String): CustomersInsertBuilder = put(Customers.addressLine1, value)
    fun addressLine2(value: String?): CustomersInsertBuilder = put(Customers.addressLine2, value)
    fun city(value: String): CustomersInsertBuilder = put(Customers.city, value)
    fun state(value: String?): CustomersInsertBuilder = put(Customers.state, value)
    fun postalCode(value: String?): CustomersInsertBuilder = put(Customers.postalCode, value)
    fun country(value: String): CustomersInsertBuilder = put(Customers.country, value)
    fun salesRepEmployeeNumber(value: Long?): CustomersInsertBuilder = put(Customers.salesRepEmployeeNumber, value)
    fun creditLimit(value: java.math.BigDecimal?): CustomersInsertBuilder = put(Customers.creditLimit, value)

    fun mandatoryColumns(customerNumber: Long, customerName: String, contactLastName: String, contactFirstName: String, phone: String, addressLine1: String, city: String, country: String) : CustomersInsertBuilder {
      mandatory(Customers.customerNumber, customerNumber)
      mandatory(Customers.customerName, customerName)
      mandatory(Customers.contactLastName, contactLastName)
      mandatory(Customers.contactFirstName, contactFirstName)
      mandatory(Customers.phone, phone)
      mandatory(Customers.addressLine1, addressLine1)
      mandatory(Customers.city, city)
      mandatory(Customers.country, country)
      return this
    }


    override fun insertRow(rowData: TableRowData<*, *>): Long {
      rowData as CustomersRow
      add(Customers.customerNumber, rowData.customerNumber)
      add(Customers.customerName, rowData.customerName)
      add(Customers.contactLastName, rowData.contactLastName)
      add(Customers.contactFirstName, rowData.contactFirstName)
      add(Customers.phone, rowData.phone)
      add(Customers.addressLine1, rowData.addressLine1)
      add(Customers.addressLine2, rowData.addressLine2)
      add(Customers.city, rowData.city)
      add(Customers.state, rowData.state)
      add(Customers.postalCode, rowData.postalCode)
      add(Customers.country, rowData.country)
      add(Customers.salesRepEmployeeNumber, rowData.salesRepEmployeeNumber)
      add(Customers.creditLimit, rowData.creditLimit)
      return execute()
    }    
        
}


data class CustomersRow(
  val customerNumber: Long,
  val customerName: String,
  val contactLastName: String,
  val contactFirstName: String,
  val phone: String,
  val addressLine1: String,
  val addressLine2: String?,
  val city: String,
  val state: String?,
  val postalCode: String?,
  val country: String,
  val salesRepEmployeeNumber: Long?,
  val creditLimit: java.math.BigDecimal?    
) : TableRowData<CustomersUpdateBuilder, CustomersInsertBuilder>(Customers.metadata()){
     override val primaryKeys = listOf<Pair<AnyColumn, Any?>>(Pair(Customers.customerNumber, customerNumber))
}
        
