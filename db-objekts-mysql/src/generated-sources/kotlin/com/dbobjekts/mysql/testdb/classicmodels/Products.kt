package com.dbobjekts.mysql.testdb.classicmodels

import com.dbobjekts.api.AnyColumn
import com.dbobjekts.api.TableRowData
import com.dbobjekts.metadata.Table
import com.dbobjekts.metadata.column.BigDecimalColumn
import com.dbobjekts.metadata.column.ForeignKeyVarcharColumn
import com.dbobjekts.metadata.column.IntegerColumn
import com.dbobjekts.metadata.column.VarcharColumn
import com.dbobjekts.statement.WriteQueryAccessors
import com.dbobjekts.statement.insert.InsertBuilderBase
import com.dbobjekts.statement.update.HasUpdateBuilder
import com.dbobjekts.statement.update.UpdateBuilderBase

/**           
 * Auto-generated metadata object for db table classicmodels.products.
 *
 * Do not edit this file manually! Always use [com.dbobjekts.codegen.CodeGenerator] when the metadata model is no longer in sync with the database.           
 *
 * Primary keys: productCode
 *
 * Foreign keys to: 
 * References by: classicmodels.productlines,classicmodels.orderdetails
 */
object Products:Table<ProductsRow>("products"), HasUpdateBuilder<ProductsUpdateBuilder, ProductsInsertBuilder> {
    /**
     * Represents db column classicmodels.products.productCode
     */
    val productcode = VarcharColumn(this, "productCode")
    /**
     * Represents db column classicmodels.products.productName
     */
    val productname = VarcharColumn(this, "productName")
    /**
     * Represents db column classicmodels.products.productLine
     *
     * Foreign key to classicmodels.productlines.productLine
     */
    val productline = ForeignKeyVarcharColumn(this, "productLine", Productlines.productline)
    /**
     * Represents db column classicmodels.products.productScale
     */
    val productscale = VarcharColumn(this, "productScale")
    /**
     * Represents db column classicmodels.products.productVendor
     */
    val productvendor = VarcharColumn(this, "productVendor")
    /**
     * Represents db column classicmodels.products.productDescription
     */
    val productdescription = VarcharColumn(this, "productDescription")
    /**
     * Represents db column classicmodels.products.quantityInStock
     */
    val quantityinstock = IntegerColumn(this, "quantityInStock")
    /**
     * Represents db column classicmodels.products.buyPrice
     */
    val buyprice = BigDecimalColumn(this, "buyPrice")
    /**
     * Represents db column classicmodels.products.MSRP
     */
    val msrp = BigDecimalColumn(this, "MSRP")
    override val columns: List<AnyColumn> = listOf(productcode,productname,productline,productscale,productvendor,productdescription,quantityinstock,buyprice,msrp)
    override fun toValue(values: List<Any?>) = ProductsRow(values[0] as String,values[1] as String,values[2] as String,values[3] as String,values[4] as String,values[5] as String,values[6] as Int,values[7] as java.math.BigDecimal,values[8] as java.math.BigDecimal)
    override fun metadata(): WriteQueryAccessors<ProductsUpdateBuilder, ProductsInsertBuilder> = WriteQueryAccessors(ProductsUpdateBuilder(), ProductsInsertBuilder())
}

class ProductsUpdateBuilder() : UpdateBuilderBase(Products) {
    fun productcode(value: String): ProductsUpdateBuilder = put(Products.productcode, value)
    fun productname(value: String): ProductsUpdateBuilder = put(Products.productname, value)
    fun productline(value: String): ProductsUpdateBuilder = put(Products.productline, value)
    fun productscale(value: String): ProductsUpdateBuilder = put(Products.productscale, value)
    fun productvendor(value: String): ProductsUpdateBuilder = put(Products.productvendor, value)
    fun productdescription(value: String): ProductsUpdateBuilder = put(Products.productdescription, value)
    fun quantityinstock(value: Int): ProductsUpdateBuilder = put(Products.quantityinstock, value)
    fun buyprice(value: java.math.BigDecimal): ProductsUpdateBuilder = put(Products.buyprice, value)
    fun msrp(value: java.math.BigDecimal): ProductsUpdateBuilder = put(Products.msrp, value)
    
    /**
     * FOR INTERNAL USE ONLY
     */
    override fun updateRow(rowData: TableRowData<*, *>): Long {
      rowData as ProductsRow
      add(Products.productcode, rowData.productcode)
      add(Products.productname, rowData.productname)
      add(Products.productline, rowData.productline)
      add(Products.productscale, rowData.productscale)
      add(Products.productvendor, rowData.productvendor)
      add(Products.productdescription, rowData.productdescription)
      add(Products.quantityinstock, rowData.quantityinstock)
      add(Products.buyprice, rowData.buyprice)
      add(Products.msrp, rowData.msrp)
      return where(Products.productcode.eq(rowData.productcode))
    }    
        
}

class ProductsInsertBuilder():InsertBuilderBase(){
    fun productcode(value: String): ProductsInsertBuilder = put(Products.productcode, value)
    fun productname(value: String): ProductsInsertBuilder = put(Products.productname, value)
    fun productline(value: String): ProductsInsertBuilder = put(Products.productline, value)
    fun productscale(value: String): ProductsInsertBuilder = put(Products.productscale, value)
    fun productvendor(value: String): ProductsInsertBuilder = put(Products.productvendor, value)
    fun productdescription(value: String): ProductsInsertBuilder = put(Products.productdescription, value)
    fun quantityinstock(value: Int): ProductsInsertBuilder = put(Products.quantityinstock, value)
    fun buyprice(value: java.math.BigDecimal): ProductsInsertBuilder = put(Products.buyprice, value)
    fun msrp(value: java.math.BigDecimal): ProductsInsertBuilder = put(Products.msrp, value)

    fun mandatoryColumns(productcode: String, productname: String, productline: String, productscale: String, productvendor: String, productdescription: String, quantityinstock: Int, buyprice: java.math.BigDecimal, msrp: java.math.BigDecimal) : ProductsInsertBuilder {
      mandatory(Products.productcode, productcode)
      mandatory(Products.productname, productname)
      mandatory(Products.productline, productline)
      mandatory(Products.productscale, productscale)
      mandatory(Products.productvendor, productvendor)
      mandatory(Products.productdescription, productdescription)
      mandatory(Products.quantityinstock, quantityinstock)
      mandatory(Products.buyprice, buyprice)
      mandatory(Products.msrp, msrp)
      return this
    }


    override fun insertRow(rowData: TableRowData<*, *>): Long {
      rowData as ProductsRow
      add(Products.productcode, rowData.productcode)
      add(Products.productname, rowData.productname)
      add(Products.productline, rowData.productline)
      add(Products.productscale, rowData.productscale)
      add(Products.productvendor, rowData.productvendor)
      add(Products.productdescription, rowData.productdescription)
      add(Products.quantityinstock, rowData.quantityinstock)
      add(Products.buyprice, rowData.buyprice)
      add(Products.msrp, rowData.msrp)
      return execute()
    }    
        
}


data class ProductsRow(
  val productcode: String,
  val productname: String,
  val productline: String,
  val productscale: String,
  val productvendor: String,
  val productdescription: String,
  val quantityinstock: Int,
  val buyprice: java.math.BigDecimal,
  val msrp: java.math.BigDecimal    
) : TableRowData<ProductsUpdateBuilder, ProductsInsertBuilder>(Products.metadata()){
     override val primaryKeys = listOf<Pair<AnyColumn, Any?>>(Pair(Products.productcode, productcode))
}
        
