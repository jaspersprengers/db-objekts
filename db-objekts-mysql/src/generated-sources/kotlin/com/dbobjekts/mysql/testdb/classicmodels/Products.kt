package com.dbobjekts.mysql.testdb.classicmodels

import com.dbobjekts.api.AnyColumn
import com.dbobjekts.api.TableRowData
import com.dbobjekts.metadata.Table
import com.dbobjekts.metadata.column.BigDecimalColumn
import com.dbobjekts.metadata.column.ForeignKeyVarcharColumn
import com.dbobjekts.metadata.column.IntegerColumn
import com.dbobjekts.metadata.column.VarcharColumn
import com.dbobjekts.statement.WriteQueryAccessors
import com.dbobjekts.statement.insert.InsertBuilderBase
import com.dbobjekts.statement.update.HasUpdateBuilder
import com.dbobjekts.statement.update.UpdateBuilderBase

/**           
 * Auto-generated metadata object for db table classicmodels.products.
 *
 * Do not edit this file manually! Always use [com.dbobjekts.codegen.CodeGenerator] when the metadata model is no longer in sync with the database.           
 *
 * Primary keys: productCode
 *
 * Foreign keys to: 
 * References by: classicmodels.productlines,classicmodels.orderdetails
 */
object Products:Table<ProductsRow>("products"), HasUpdateBuilder<ProductsUpdateBuilder, ProductsInsertBuilder> {
    /**
     * Represents db column classicmodels.products.productCode
     */
    val productCode = VarcharColumn(this, "productCode")
    /**
     * Represents db column classicmodels.products.productName
     */
    val productName = VarcharColumn(this, "productName")
    /**
     * Represents db column classicmodels.products.productLine
     *
     * Foreign key to classicmodels.productlines.productLine
     */
    val productLine = ForeignKeyVarcharColumn(this, "productLine", Productlines.productLine)
    /**
     * Represents db column classicmodels.products.productScale
     */
    val productScale = VarcharColumn(this, "productScale")
    /**
     * Represents db column classicmodels.products.productVendor
     */
    val productVendor = VarcharColumn(this, "productVendor")
    /**
     * Represents db column classicmodels.products.productDescription
     */
    val productDescription = VarcharColumn(this, "productDescription")
    /**
     * Represents db column classicmodels.products.quantityInStock
     */
    val quantityInStock = IntegerColumn(this, "quantityInStock")
    /**
     * Represents db column classicmodels.products.buyPrice
     */
    val buyPrice = BigDecimalColumn(this, "buyPrice")
    /**
     * Represents db column classicmodels.products.MSRP
     */
    val msrp = BigDecimalColumn(this, "MSRP")
    override val columns: List<AnyColumn> = listOf(productCode,productName,productLine,productScale,productVendor,productDescription,quantityInStock,buyPrice,msrp)
    override fun toValue(values: List<Any?>) = ProductsRow(values[0] as String,values[1] as String,values[2] as String,values[3] as String,values[4] as String,values[5] as String,values[6] as Int,values[7] as java.math.BigDecimal,values[8] as java.math.BigDecimal)
    override fun metadata(): WriteQueryAccessors<ProductsUpdateBuilder, ProductsInsertBuilder> = WriteQueryAccessors(ProductsUpdateBuilder(), ProductsInsertBuilder())
}

class ProductsUpdateBuilder() : UpdateBuilderBase(Products) {
    fun productCode(value: String): ProductsUpdateBuilder = put(Products.productCode, value)
    fun productName(value: String): ProductsUpdateBuilder = put(Products.productName, value)
    fun productLine(value: String): ProductsUpdateBuilder = put(Products.productLine, value)
    fun productScale(value: String): ProductsUpdateBuilder = put(Products.productScale, value)
    fun productVendor(value: String): ProductsUpdateBuilder = put(Products.productVendor, value)
    fun productDescription(value: String): ProductsUpdateBuilder = put(Products.productDescription, value)
    fun quantityInStock(value: Int): ProductsUpdateBuilder = put(Products.quantityInStock, value)
    fun buyPrice(value: java.math.BigDecimal): ProductsUpdateBuilder = put(Products.buyPrice, value)
    fun msrp(value: java.math.BigDecimal): ProductsUpdateBuilder = put(Products.msrp, value)
    
    /**
     * FOR INTERNAL USE ONLY
     */
    override fun updateRow(rowData: TableRowData<*, *>): Long {
      rowData as ProductsRow
      add(Products.productCode, rowData.productCode)
      add(Products.productName, rowData.productName)
      add(Products.productLine, rowData.productLine)
      add(Products.productScale, rowData.productScale)
      add(Products.productVendor, rowData.productVendor)
      add(Products.productDescription, rowData.productDescription)
      add(Products.quantityInStock, rowData.quantityInStock)
      add(Products.buyPrice, rowData.buyPrice)
      add(Products.msrp, rowData.msrp)
      return where(Products.productCode.eq(rowData.productCode))
    }    
        
}

class ProductsInsertBuilder():InsertBuilderBase(){
    fun productCode(value: String): ProductsInsertBuilder = put(Products.productCode, value)
    fun productName(value: String): ProductsInsertBuilder = put(Products.productName, value)
    fun productLine(value: String): ProductsInsertBuilder = put(Products.productLine, value)
    fun productScale(value: String): ProductsInsertBuilder = put(Products.productScale, value)
    fun productVendor(value: String): ProductsInsertBuilder = put(Products.productVendor, value)
    fun productDescription(value: String): ProductsInsertBuilder = put(Products.productDescription, value)
    fun quantityInStock(value: Int): ProductsInsertBuilder = put(Products.quantityInStock, value)
    fun buyPrice(value: java.math.BigDecimal): ProductsInsertBuilder = put(Products.buyPrice, value)
    fun msrp(value: java.math.BigDecimal): ProductsInsertBuilder = put(Products.msrp, value)

    fun mandatoryColumns(productCode: String, productName: String, productLine: String, productScale: String, productVendor: String, productDescription: String, quantityInStock: Int, buyPrice: java.math.BigDecimal, msrp: java.math.BigDecimal) : ProductsInsertBuilder {
      mandatory(Products.productCode, productCode)
      mandatory(Products.productName, productName)
      mandatory(Products.productLine, productLine)
      mandatory(Products.productScale, productScale)
      mandatory(Products.productVendor, productVendor)
      mandatory(Products.productDescription, productDescription)
      mandatory(Products.quantityInStock, quantityInStock)
      mandatory(Products.buyPrice, buyPrice)
      mandatory(Products.msrp, msrp)
      return this
    }


    override fun insertRow(rowData: TableRowData<*, *>): Long {
      rowData as ProductsRow
      add(Products.productCode, rowData.productCode)
      add(Products.productName, rowData.productName)
      add(Products.productLine, rowData.productLine)
      add(Products.productScale, rowData.productScale)
      add(Products.productVendor, rowData.productVendor)
      add(Products.productDescription, rowData.productDescription)
      add(Products.quantityInStock, rowData.quantityInStock)
      add(Products.buyPrice, rowData.buyPrice)
      add(Products.msrp, rowData.msrp)
      return execute()
    }    
        
}


data class ProductsRow(
  val productCode: String,
  val productName: String,
  val productLine: String,
  val productScale: String,
  val productVendor: String,
  val productDescription: String,
  val quantityInStock: Int,
  val buyPrice: java.math.BigDecimal,
  val msrp: java.math.BigDecimal    
) : TableRowData<ProductsUpdateBuilder, ProductsInsertBuilder>(Products.metadata()){
     override val primaryKeys = listOf<Pair<AnyColumn, Any?>>(Pair(Products.productCode, productCode))
}
        
