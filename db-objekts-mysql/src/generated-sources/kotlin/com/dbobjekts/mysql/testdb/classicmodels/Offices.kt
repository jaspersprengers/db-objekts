package com.dbobjekts.mysql.testdb.classicmodels

import com.dbobjekts.api.AnyColumn
import com.dbobjekts.metadata.Table
import com.dbobjekts.api.TableRowData
import com.dbobjekts.metadata.column.IsGeneratedPrimaryKey
import com.dbobjekts.api.exception.StatementBuilderException
import com.dbobjekts.statement.WriteQueryAccessors
import com.dbobjekts.statement.update.HasUpdateBuilder
import com.dbobjekts.statement.insert.InsertBuilderBase
import com.dbobjekts.statement.update.UpdateBuilderBase


/**           
 * Auto-generated metadata object for db table classicmodels.offices.
 *
 * Do not edit this file manually! Always use [com.dbobjekts.codegen.CodeGenerator] when the metadata model is no longer in sync with the database.           
 *
 * Primary keys: officeCode
 *
 * Foreign keys: [] 
 */
object Offices:Table<OfficesRow>("offices"), HasUpdateBuilder<OfficesUpdateBuilder, OfficesInsertBuilder> {
    /**
     * Represents db column classicmodels.offices.officeCode
     */
    val officecode = com.dbobjekts.metadata.column.VarcharColumn(this, "officeCode")
    /**
     * Represents db column classicmodels.offices.city
     */
    val city = com.dbobjekts.metadata.column.VarcharColumn(this, "city")
    /**
     * Represents db column classicmodels.offices.phone
     */
    val phone = com.dbobjekts.metadata.column.VarcharColumn(this, "phone")
    /**
     * Represents db column classicmodels.offices.addressLine1
     */
    val addressline1 = com.dbobjekts.metadata.column.VarcharColumn(this, "addressLine1")
    /**
     * Represents db column classicmodels.offices.addressLine2
     */
    val addressline2 = com.dbobjekts.metadata.column.NullableVarcharColumn(this, "addressLine2")
    /**
     * Represents db column classicmodels.offices.state
     */
    val state = com.dbobjekts.metadata.column.NullableVarcharColumn(this, "state")
    /**
     * Represents db column classicmodels.offices.country
     */
    val country = com.dbobjekts.metadata.column.VarcharColumn(this, "country")
    /**
     * Represents db column classicmodels.offices.postalCode
     */
    val postalcode = com.dbobjekts.metadata.column.VarcharColumn(this, "postalCode")
    /**
     * Represents db column classicmodels.offices.territory
     */
    val territory = com.dbobjekts.metadata.column.VarcharColumn(this, "territory")
    override val columns: List<AnyColumn> = listOf(officecode,city,phone,addressline1,addressline2,state,country,postalcode,territory)
    override fun toValue(values: List<Any?>) = OfficesRow(values[0] as String,values[1] as String,values[2] as String,values[3] as String,values[4] as String?,values[5] as String?,values[6] as String,values[7] as String,values[8] as String)
    override fun metadata(): WriteQueryAccessors<OfficesUpdateBuilder, OfficesInsertBuilder> = WriteQueryAccessors(OfficesUpdateBuilder(), OfficesInsertBuilder())
}

class OfficesUpdateBuilder() : UpdateBuilderBase(Offices) {
    fun officecode(value: String): OfficesUpdateBuilder = put(Offices.officecode, value)
    fun city(value: String): OfficesUpdateBuilder = put(Offices.city, value)
    fun phone(value: String): OfficesUpdateBuilder = put(Offices.phone, value)
    fun addressline1(value: String): OfficesUpdateBuilder = put(Offices.addressline1, value)
    fun addressline2(value: String?): OfficesUpdateBuilder = put(Offices.addressline2, value)
    fun state(value: String?): OfficesUpdateBuilder = put(Offices.state, value)
    fun country(value: String): OfficesUpdateBuilder = put(Offices.country, value)
    fun postalcode(value: String): OfficesUpdateBuilder = put(Offices.postalcode, value)
    fun territory(value: String): OfficesUpdateBuilder = put(Offices.territory, value)
    
    /**
     * FOR INTERNAL USE ONLY
     */
    override fun updateRow(rowData: TableRowData<*, *>): Long {
      rowData as OfficesRow
      add(Offices.officecode, rowData.officecode)
      add(Offices.city, rowData.city)
      add(Offices.phone, rowData.phone)
      add(Offices.addressline1, rowData.addressline1)
      add(Offices.addressline2, rowData.addressline2)
      add(Offices.state, rowData.state)
      add(Offices.country, rowData.country)
      add(Offices.postalcode, rowData.postalcode)
      add(Offices.territory, rowData.territory)
      return where(Offices.officecode.eq(rowData.officecode))
    }    
        
}

class OfficesInsertBuilder():InsertBuilderBase(){
    fun officecode(value: String): OfficesInsertBuilder = put(Offices.officecode, value)
    fun city(value: String): OfficesInsertBuilder = put(Offices.city, value)
    fun phone(value: String): OfficesInsertBuilder = put(Offices.phone, value)
    fun addressline1(value: String): OfficesInsertBuilder = put(Offices.addressline1, value)
    fun addressline2(value: String?): OfficesInsertBuilder = put(Offices.addressline2, value)
    fun state(value: String?): OfficesInsertBuilder = put(Offices.state, value)
    fun country(value: String): OfficesInsertBuilder = put(Offices.country, value)
    fun postalcode(value: String): OfficesInsertBuilder = put(Offices.postalcode, value)
    fun territory(value: String): OfficesInsertBuilder = put(Offices.territory, value)

    fun mandatoryColumns(officecode: String, city: String, phone: String, addressline1: String, country: String, postalcode: String, territory: String) : OfficesInsertBuilder {
      mandatory(Offices.officecode, officecode)
      mandatory(Offices.city, city)
      mandatory(Offices.phone, phone)
      mandatory(Offices.addressline1, addressline1)
      mandatory(Offices.country, country)
      mandatory(Offices.postalcode, postalcode)
      mandatory(Offices.territory, territory)
      return this
    }


    override fun insertRow(rowData: TableRowData<*, *>): Long {
      rowData as OfficesRow
      add(Offices.officecode, rowData.officecode)
      add(Offices.city, rowData.city)
      add(Offices.phone, rowData.phone)
      add(Offices.addressline1, rowData.addressline1)
      add(Offices.addressline2, rowData.addressline2)
      add(Offices.state, rowData.state)
      add(Offices.country, rowData.country)
      add(Offices.postalcode, rowData.postalcode)
      add(Offices.territory, rowData.territory)
      return execute()
    }    
        
}


data class OfficesRow(
  val officecode: String,
  val city: String,
  val phone: String,
  val addressline1: String,
  val addressline2: String?,
  val state: String?,
  val country: String,
  val postalcode: String,
  val territory: String    
) : TableRowData<OfficesUpdateBuilder, OfficesInsertBuilder>(Offices.metadata()){
     override val primaryKeys = listOf<Pair<AnyColumn, Any?>>(Pair(Offices.officecode, officecode))
}
        
