:toc:

= Introduction
:imagesdir: ./docs

NOTE: db-Objekts is currently in alpha. The API is still subject to change and is not production ready. During the alpha release it will only support MariaDB.
The plan is to release a beta early 2023 followed by a first release later that year. This release will support MySQL, PostgreSQLS and Oracle. See <<_status_and_roadmap>> for the planning

== Fluent, type-safe, lightweight and opinionated
db-Objekts is a Kotlin library to perform queries on a relational databases in application code.
It generates source code that acts as metadata for all tables, columns and foreign keys. You then use these stateless Kotlin objects to build type-safe and fluent queries, comfortably using
your IDE's autocomplete, while db-Objekts takes care of the SQL boilerplate and type conversions.

The project was conceived and built by me, Jasper Sprengers, a software developer living in the Netherlands.

db-Objekts has some conceptual similarities to object relational mapping frameworks like Hibernate, but is also quite different. ORMs work with stateful entities that abstract away the database layer, even the individual tables. They are certainly not lightweight of easy to master well. db-Objekts is firmly focused on executing queries on tables, but these tables have become part of your application's source code. This gives you all the benefits of your IDE's auto-complete features, in addition to Kotlin's type and null-safety.

Let's start with an overview of features.

== A bird's eye feature view
Let's showcase the features in a concise demonstration to get a feel of what you can achieve with db-Objekts.

We have a simple database of a lending library with five tables
* `author` represents a person, with name, bio, and data of birth.
* `book` has the official isbn as its primary key, a title, year of publication and a reference to its author.
* `item` represents a physical copy of a book. It refers to the `book` table and stores the date of acquisition. There can be zero or more copies of a book title.
* `member` only stores the name of an invdividual member
* `loan` keeps a record of all the books (items) taken out by a member. It refers to `item` and `member` and keeps the date taken out and returned.

image::datamodel.png[datamodel,600]

First we need metadata objects for our database. For this we need the `CodeGenerator`
```kotlin
val generator = CodeGenerator()
       .withDataSource(datasource = H2DB.dataSource)
generator.outputConfigurer()
        .basePackageForSources("com.acme.db-Objekts")
        .outputDirectoryForGeneratedSources(Paths.get("src/gen/kotlin").toAbsolutePath().toString())
generator.generateSourceFiles()
```

This is a bare-bones setup. There is much more to fine-tune. This writes metadata objects under the package `com.acme.db-Objekts` in a special `gen` source folder, which indicates you should not manually alter these files.

The next step is to configure the `TransactionManager`. This wraps a `javax.sql.DataSource` and acts as a factory for transactions.
You typically only need one instance per database. This example is for an embedded H2 database, taken from the project `com.db-Objekts.sampledbs.h2.H2DB`
The code generation stage produced a `AcmeCatalog` Kotlin `object`. dbo needs this to produce SQL boilerplate specific to our schemas.
```kotlin
val dataSource = HikariDataSourceFactory.create(url = "jdbc:h2:mem:test", username = "sa", password = null, driver = "org.h2.Driver")
val transactionManager = TransactionManager.builder()
    .withCatalog(TestCatalog)
    .withDataSource(dataSource).build()
```

To get a connection from the `TransactionManager` and start performing queries, use the following syntax (we'll use `tm` for `TransactionManager` instances and `tr` for `Transaction` throughout this tutorial)
```kotlin
val resultOfQuery = tm.newTransaction { tr->
    //execute your query/queries here
}
```
The `newTransaction()` method's signature is `fun <T> newTransaction(function: (Transaction) -> T): T`. You provide it with a lambda that takes a `Transaction` and can produce any result. The `invoke()` operator does the same, so you can express it even more concisely:
```kotlin
val books: List<String> = tm { it.select(Book.isbn).asList() }
```

That was our very first query: select the ISBN column from the `book` and return it as a `List<String`. Now let's add some authors, titles and members.
The `mandatoryColumns(..)` call is a convenience method to make sure you don't miss any of the non-null columns in your insert.
When the table in question has an auto-generated id, it is returned as a `Long`. We need to store it for later.
```kotlin
val orwell: Long = tr.insert(Author).mandatoryColumns("George Orwell").execute()
val rowling: Long = tr.insert(Author).mandatoryColumns("Joanne (J.K.) Rowling").execute()

// the primary key of the book table is not auto-generated. In this case execute() returns 1.
tr.insert(Book).mandatoryColumns("ISBN-1984", "Nineteen-eighty Four", orwell, LocalDate.of(1948,1,1)).execute()
tr.insert(Book).mandatoryColumns("ISBN-WIGAN", "The Road to Wigan Pier", orwell, LocalDate.of(1940,1,1)).execute()
tr.insert(Book).mandatoryColumns("ISBN-PHILOSOPHER", "Harry Potter and the Philosopher's Stone", rowling, LocalDate.of(1999,1,1)).execute()

val john = tr.insert(Member).mandatoryColumns("John").execute()
val sally = tr.insert(Member).mandatoryColumns("Sally").execute()
```
We forgot to put a bio for George Orwell. Let's do that now. Notice the use of the where clause. Common sql operator symbols (=,<,>,!=) have textual counterparts.
And yes, you can do embedded and/or conditions. More on that later.
```kotlin
  tr.update(Author)
      .bio("(1903-1950) Pseudonym of Eric Blair. Influential writer of novels, essays and journalism.")
      .where(Author.id.eq(orwell))
```
Notice the power of autocomplete here. You instantly know which columns are available, which types they take, and whether null values are allowed.

image::autocomplete_update.png[autocomplete_update, 600]

image::autocomplete_insert.png[autocomplete_insert, 600]

Add some physical copies and loan data
```kotlin
//we have two copies of Harry Potter, one of 1984 and we misplaced the one of the Road to Wigan Pier.
val copy1_1984 = tr.insert(Item).mandatoryColumns("ISBN-1984", LocalDate.of(1980,5,5)).execute()
val copy1_phil = tr.insert(Item).mandatoryColumns("ISBN-PHILOSOPHER", LocalDate.of(2005,5,5)).execute()
val copy2_phil = tr.insert(Item).mandatoryColumns("ISBN-PHILOSOPHER", LocalDate.of(2005,5,5)).execute()
//Sally takes out 1984 and Harry Potter. John takes the other Harry Potter copy
tr.insert(Loan).mandatoryColumns(memberId = sally, itemId = copy1_1984, dateLoaned = LocalDate.now()).execute()
tr.insert(Loan).mandatoryColumns(memberId = sally, itemId = copy1_phil, dateLoaned = LocalDate.now()).execute()
tr.insert(Loan).mandatoryColumns(memberId = john, itemId = copy2_phil, dateLoaned = LocalDate.now()).execute()
```

Now we can start querying. Let's get a list of all titles and their author data. This is what a select query in dbo looks like. You will notice that there is no `from` clause. All the information is present in the column references that you provide in the call to `select(..`) and dbo is can figure out the necessary table joins. The terminating `asList()` call returns a list of type-safe tuples that correspond exactly to the number and types of the columns in the `select(..)` call. Notice that `Author.bio` is a nullable column. Hence, the corresponding value in the tuple is `String?`, not `String`.
```kotlin
val bookAuthors: List<Tuple3<String, String, String?>> = tr.select(Book.title, Author.name, Author.bio).asList()
```
Let's take it up a notch! This query involves all five tables and returns `List<Tuple5<LocalDate, Long, String, String, String>>`. Since all `Tuple*` classes are data classes, you can deconstruct them into a more readable output
```kotlin
tr.select(Loan.dateLoaned, Item.id, Book.title, Author.name, Member.name).asList()
  .forEach { (dateLoaned, item, book, author, member) ->
    println("Item $item of $book by $author loaned to $member on $dateLoaned")
  }
 // the type returned is List<Tuple5<LocalDate, Long, String, String, String>>
 //Item 1 of Nineteen-eighty Four by George Orwell loaned to Sally on 2022-12-23
 //Item 4 of Harry Potter and the Philsopher's Stone by Joanne Rowling loaned to Sally on 2022-12-23
 //Item 5 of Harry Potter and the Philsopher's Stone by Joanne Rowling loaned to John on 2022-12-23
```
This concludes our bird's eye view of dbo. There is much, much more to explore in the following sections, so let's dig in!

== Getting started


=== Installation and configuration
dbo is a single jar, depending on your vendor. Get the latest release from Maven central

=== Generating metadata objects
Before we dive into the details of code generation, some clarification is in order.

Auto-generating code is an established practice for service specifications and DTO (data transfer objects) and has been with us since WSDL. You can create richly annotated interfaces from an `openapi.yaml` file that specify the available REST endpoints and expected messages. By implementing these interfaces you create a compile-time dependency on the generated code.

dbo is similar in that regard: the generated metadata objects that stand for the tables and columns become tightly coupled to your source code. That is a good thing, because the database itself _is_ an integral part of the application logic, whatever tool you use to interact with it. If you connect through native SQL, structural changes to the schemas will go unnoticed unless you have strong integration tests (unit tests won't catch it). The more likely alternative is for things to break in production.

When a component (and team) implements a service, it often also owns the specification, and the file(s) will be part of the source repository. There are no unexpected surprises, and it's fine to re-generate the code whenever you do a fresh build, during the generate-sources phase, which takes place before compilation. The big difference with basing yourself on a SQL specification is one of ownership: your project may not own the database structure. In the worst case, unannounced changes may completely mess up the status quo.

==== Code generation and validation during the SDLC
Generating code is harmless when you're starting out with dbo, since there's no source code that uses the new objects. When changes to the structure are carried out, it makes sense to inspect the changes before overwriting anything. The following is strongly advised:

* Always write generated code in a separate source folder, called `gen` or `generated-sources`. This is a reminder that you should never manually change this code.
* Add the kotlin source files to source control, even when they are generated. Remember, the state of the database may not be part of the same versioned repository.
* Include an automated test as part of the build to validate the database against the generated sources. See https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-mariadb/src/test/kotlin/com.dbobjekts.mariadb/MariaDBIntegrationTest.kt[MariaDBIntegrationTest] for an example

=== Code generation in detail
With these warnings in mind, let's have a detailed look at the process. https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/codegen/CodeGenerator.kt[CodeGenerator] is our port of call for the entire process.
Configuration is grouped into the following sections:

* The mandatory javax.sql.DataSource.
* Configuration for exclusions.
* Configuration for mapping column types to SQL types, using custom type for certain columns, and setting the sequence names for auto-generated keys.
* Configuration of the output: the folder to write to and the base package structure to use, e.g. `com.acme.dbmetadata`.

==== Setting the dataSource
Make sure the user has sufficient privileges to read the relevant metadata tables (INFORMATION_SCHEMA in MySQL/MariaDB)
```kotlin
   val generator = CodeGenerator().withDataSource(myDataSource)
```
==== Exclusions
Certain schemas, tables or columns may have to be ignored, for various reasons.
```kotlin

```
==== Overriding a column type by SQL type
dbo chooses a suitable implementation of https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/metadata/column/Column.kt[Column], depending on the vendor type. Sometimes you want to fine-tune this mapping. The MySQL type `TINYINT(1)` is mapped to a `Byte` by default, but as it is often used as a boolean value, you can choose to map it to a `BooleanColumn`.

==== Overriding a column by name

=== Setting sequence names
Many vendors support sequences for generating primary keys, but the information schema does not store which sequence is used for which table. So, unfortunately, you have to manually configure this, as follows:
```kotlin
 generator.mappingConfigurer()
            .setSequenceNameForPrimaryKey("core", "employee", "id", "EMPLOYEE_SEQ")
```
This is fine if you have a small schema, but cumbersome if you have > 100 tables to configure. If you have a consistent naming scheme, you can write your own implementation of `SequenceForPrimaryKeyResolver`
```kotlin
generator.mappingConfigurer()
 .sequenceForPrimaryKeyResolver(AcmeSequenceMapper)

  object AcmeSequenceMapper : SequenceForPrimaryKeyMapper {
        override fun invoke(properties: ColumnMappingProperties): String? =
            if (properties.isPrimaryKey) properties.table.value + "_SEQ" else null
    }
```
==== Output configuration

==== Supported vendors


==== Mandatory settings
TBD

==== Excluding objects from generation
TBD

==== Overriding the default Column implementation
TBD

==== Using sequence-generated primary keys
TBD

== db-Objekts metadata
TBD

=== Catalog, Schema and Table
TBD

=== Columns
TBD

== Querying
TBD

=== The TransactionManager and Transaction
TBD

=== Inserting data
Let's start with getting some data into the tables. The `insert(..)` method takes a (generated) `Table` implementation and returns a corresponding `*InsertBuilder` instance.
In the example below these would be `CountryInsertBuilder` and `EmployeeInsertBuilder`.

The insert builders contain setter methods for all columns. In addition it has a handy `mandatoryColumns(..)` shortcut (provided the table has at least one non-nullable column) to make sure you provide all the required values.

```kotlin
  transaction.insert(Country).mandatoryColumns("nl", "Netherlands").execute()
  val petesId: Long = transaction.insert(Employee).mandatoryColumns("Pete", 5020.34, LocalDate.of(1980, 5, 7)).married(true).execute()
```

- The `Country` object has two mandatory columns and no auto-generated key. The `execute()` method returns the value of the JDBC call `PreparedStatement.executeUpdate()`, which should be 1 for a successful insert.
- The `Employee` table has four mandatory columns. The optional `married` property is set in a setter method. The table has a generated primary key, which is returned by the `execute()` method.

=== Updating and deleting
Update statements have a similar syntax, so let's discuss them now before moving on the more elaborate select statements. The `update(..)` method also takes a table and returns a `*UpdateBuilder` object.

```kotlin
 transaction.update(Employee).salary(4500.30).married(null).where(e.id.eq(12345))
```

- There is no `mandatoryColumns()` method.
- You can provide a null to a setter method if the corresponding database column is nullable: `update(Employee).married(null)`.
- Note that you cannot do the same with `salary`, because that is non-nullable: `.salary(null)` will not compile
- A where-clause is optional. This will update all rows in the table, so watch out.
- You close the statement with an explicit `execute()`.

=== The where-clause in details
Update, select and delete are executed against a range of database rows that satisfy certain criteria. These criteria are expressed in the where-clause.
The possibilities for generated db-Objekts statements are not as flexible as what you can achieve in native SQL, but they are more convenient to use and still cover a lot of common scenarios.

The canonical form of the where clause is `statement.where(column .. operator .. [value, otherColumn] [and|or] ... )` which is quite analogous to normal SQL usage.

```kotlin
 where(Employee.name.eq("Janet"))
 where(Employee.dateOfBirth.gt(LocalDate.of(1980,1,1)))
```
These are the operators you can use.

- `eq`: is equal to
- `ne`: is not equal to.
- `gt`: is greater than.
- `lt`: is less than.
- `gte`: is greater than or equal.
- `lte`: is less than or equal.
- `within`: is within a range of values.
- `notIn`: is not within a range of values.
- `startsWith`: (for character type only)
- `endsWith`: (for character type only)
- `contains`:  (for character type only)
- `isNull`
- `isNotNull`

You can chain conditions using `and` or `or` and you can even build nested conditions:

```kotlin
  where(e.married.eq(true).or(e.name.eq("John").or(e.name).eq("Bob"))) // all married people, plus John and Bob
```

- If you have no conditions to constrain your selection you omit the where clause in SQL. In db-Objekts you have to close the select/update/delete statement with `noWhereClause()`. Be very careful, especially with deleting!

=== Basic select statements
Let's move on to Select statements now. The pattern is `transaction.select( col1, col2, ... ).where( conditions ).[first()|asList()]`. You start with listing the columns you want to retrieve, the whereclause (or `noWhereClause`) and then retrieve a list of results

This query selects name and salary for all rows in the employee table. Notice we have imported the 'e' alias from the Aliases object. This is a handy shortcut that refers to the exact same Employee object.
```kotlin
 val asList: List<Pair<Long, String>> = it.select(e.id, e.name).noWhereClause().asList() // potentially empty
 val asOption: Pair<Long, String>? = it.select(e.id, e.name).noWhereClause().firstOrNull() // None if no row can be retrieved
 val singleResult: Pair<Long, String> = it.select(e.id, e.name).noWhereClause().first() //Will throw an exception if no row can be found
```

The result is always a Tuple object that corresponds in size and type to the colummns you specified in the `.select(..)` call. For null-safety's sake all values are returned as nullable types, because primitive instances (Int, Long, Boolean etc.) cannot be null in Kotlin, but *can* be null in the database.

The power of relational databases lies in combining results from multiple tables by laying the proper join conditions. The `Employee` and `Address` tables are linked via the `EmployeeAddress` table in a many-to-many fashion. Since the foreign key relations are explicit in the source code, db-Objekts can build the joins for you:

```kotlin
  transaction.select(e.name, e.dateOfBirth, e.children, e.married).where(Address.street.eq("Pete Street")).asList()
```

We can select from the `Employee` table with a constraint on the `Address` table, without specifying the join! This mechanism saves you a lot of typing, but comes with limitations:
1) There must be an explicit foreign-key relationship between the tables used in your statement, or a join table that links two tables referred in your query, like in the above example.
2) all joins are left outer joins.

If the framework cannot unambiguously resolve the join conditions, you have to provide them yourself. Call the `from(SomeTable)` method with the driving table of your selection, and add the tables to joined as follows:

```kotlin
 transaction.select(e.name, c.name)
      .from(Employee.innerJoin(ea).innerJoin(Address).innerJoin(Country))
      .where(ea.kind eq "WORK").asList()
```

This resolves to the following SQL:

```sql
 FROM EMPLOYEE e JOIN EMPLOYEE_ADDRESS ae on e.id = ae.employee_id JOIN ADDRESS a on a.id = ae.address_id join COUNTRY c on c.id = a.country_id
```

`asList` always return a (potentially empty) list of results. If one row is all you need, you can invoke `first()` or the safer option `firstOrNull()`, since the former will throw if the resultset was empty.

When you execute a select statement, db-Objekts pulls all results into a list structure, which add to the JVM heap. This may not be what you want.
The `forEachRow()` call lets you inspect the resultset row by row through a custom predicate so you can decide how to handle them and even abort further retrieval, which means reduced traffic from the RDBMS to your application.
```kotlin
  val buffer = mutableListOf<String?>()
    transaction.select(e.name).noWhereClause().orderAsc(e.name).forEachRow({ row ->
    buffer.add(row)
    //there are three rows in the resultset, but we stop fetching after two
    buffer.size != 2
})
```

You can further tweak select results with the `orderBy` and `limit(..)` methods. This orders all employees by salary (highest first), then by name (A-Z), and retrieves the first ten rows.
Note that these constraints are executed server-side, as they are part of the SQL. db-Objekts takes care of the proper syntax, because vendors handle the limit clause differently.

```kotlin
  tr.select(e.name).noWhereClause.orderDesc(e.salary).orderAsc(e.name).limit(10).asList()
```

=== Outer joins and more customization
TBD

=== Custom sql queries
TBD

== Advanced topics
TBD

=== Customizing the code generation
TBD

=== Creating custom column types
TBD

== Status and roadmap
db-Objekts has been a long time in the making. I started it in Scala, but switched to Kotlin because its null-safety is perfectly suited to the world of (relational) data. For several years it remained a hobby project and was not mature enough to become the Open Source tool I had in mind. But that time has now come.

This is the very first alpha release. The API may change slightly, so it is not yet ready for a beta release and you should not use it in production yet. While I'm confident and proud of my work, more rigorous testing is needed.

=== Roadmap

* From Januari 2023 a number of alpha releases will cover the following
**  Close to 100% unit test coverage
** Full coverage for all column types in the H2 database, used for testing
** Improving and cleaning up source code documentation and user docs
** Minor alterations the API with regard to method names and possible refactoring of packages

* The beta release planned for spring 2023 will cover:
** Addition of PostgreSQL and MySQL as vendor types
** Rigorous integration tests on dockerized images of all database vendors as part of the build
** No more API changes are to be expected.
