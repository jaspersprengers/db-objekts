:toc:

= Introduction
:imagesdir: ./docs

NOTE: db-Objekts is currently in alpha. The API is subject to change and not ready for production. At present it only supports H2 and MariaDB.
A beta is planned for early 2023 and hopefully a first stable release later that year. This will at least support MySQL, PostgreSQL and Oracle. See xref:_status_and_roadmap[for the planning]

== Fluent, type-safe, lightweight and opinionated
db-Objekts is a Kotlin library to build relational database queries. It uses generated Kotlin metadata objects that represent the tables, columns and foreign keys. Its DSL lets you write type-safe and fluent queries while db-Objekts takes care of join syntax and type conversions. The project was conceived and built by https://jaspersprengers.eu[Jasper Sprengers]. I am a software developer living in the Netherlands.

In short, db-Objekts lets you do things like this:
```kotlin
tr.select(Employee, Address, EmployeeAddress.kind, Country.name)
                    .where(Employee.id.eq(empId)).asList().forEach {
                        (emp, add, addType, country) ->
                        println("${emp.name}'s $addType address is ${add.street} ${add.postcode}, $country")
                        //Example: John's HOME address is Zuidhoek 80 3082TR, Nederland
                    }
```

It exploits the power and convenience of your IDE's auto-complete to the full.

image::autocomplete.png[autocomplete, 600]

=== So, is this going to make ORM obsolete?
The short answer is no.

db-Objekts is quite different from object relational mapping (ORM) frameworks and serves a different use case. ORMs work with stateful entities that abstract away tables and foreign keys, but they are only easy when your needs are simple. They work fine at the level of individual entities, but performance at scale is hard. They are neither lightweight nor easy to master in-depth.

db-Objekts is deliberately limited in its capabilities. It does not emulate all that is possible in native SQL or Hibernate and encourages you to use it alongside such tools, depending on the individual query requirements.

== A bird's eye view of features
Let's start with an overview of feature. (https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/AcmeCatalogCodeGenComponentTest.kt[full source code])

We have a simple in-memory H2 database that models a lending library with five tables

image::datamodel.png[datamodel,600]

The first step is to create our metadata objects. You do this at the outset and whenever the db structure changes.
```kotlin
val generator = CodeGenerator()
       .withDataSource(datasource = H2DB.dataSource)
generator.outputConfigurer()
        .basePackageForSources("com.acme.dbobjekts")
        .outputDirectoryForGeneratedSources(Paths.get("src/gen/kotlin")
            .toAbsolutePath().toString())
generator.generateSourceFiles()
```

This is a bare-bones setup that has produced a package `com.acme.dbobjekts` in the `gen` source folder. We now have `Book`, `Author`, `Loan`,`Item` and `Member` source files that correspond to the tables. Tying the schema(s) and tables together is also a `CatalogDefinition` object.

Per application you also configure a `TransactionManager`, which takes a `javax.sql.DataSource` and the  `CatalogDefinition` that was just generated. An in-memory H2 db works great for testing.

```kotlin
val dataSource = HikariDataSourceFactory.create("jdbc:h2:mem:test","sa",null)
val transactionManager = TransactionManager.builder()
    .withCatalog(CatalogDefinition)
    .withDataSource(dataSource).build()
```
The `TransactionManager` hands out `Transaction` instances, which wrap a short-lived `javax.sql.Connection`. You use the following syntax:
```kotlin
val resultOfQuery = tm.newTransaction { tr->
    //execute your query/queries here
}
```

We'll stick to `tm` for TransactionManager and `tr` for Transaction throughout this documentation.

The signature of newTransaction is `fun <T> newTransaction(function: (Transaction) -> T): T`. The `invoke` operator does the same, so to select the isbn column from all books you can also write:
```kotlin
val books: List<String> = tm { it.select(Book.isbn).asList() }
```

That was our first query. Now let's add an author, book title and member.

```kotlin
val orwell: Long = tr.insert(Author)
    .mandatoryColumns("George Orwell").execute()

// the primary key of the book table is not auto-generated. In this case execute() returns 1.
tr.insert(Book)
    .mandatoryColumns("ISBN-1984", "Nineteen-eighty Four", orwell, LocalDate.of(1948,1,1))
    .execute()

val john = tr.insert(Member)
    .mandatoryColumns("John").execute()
```

The `mandatoryColumns(..)` call is a convenience method to make sure you provide a value for all the non-null columns. When the table in question has an auto-generated id, it is returned as a `Long`.

Let's update the George Orwell record with a bio. Notice the use of the where clause. Common sql operator symbols (=,<,>,!=) have textual counterparts `eq`, `lt`, `ne` etc,

```kotlin
  tr.update(Author)
      .bio("(1903-1950) Pseudonym of Eric Blair. Influential writer of novels, essays and journalism.")
      .where(Author.id.eq(orwell))
```
Notice the power of autocomplete. You don't need to know which columns are in a table, which types they take, and whether they allow nulls. Autocomplete instantly shows you.

image::autocomplete_update.png[autocomplete_update, 600]

image::autocomplete_insert.png[autocomplete_insert, 600]

Add a physical copy of the book and a loan record.
```kotlin
val copy1984 = tr.insert(Item)
    .mandatoryColumns("ISBN-1984", LocalDate.of(1990,5,5))
    .execute()
//John takes out the copy of 1984 which was acquired in 1990
tr.insert(Loan).mandatoryColumns(memberId = john,
    itemId = copy1984copy1984,
    dateLoaned = LocalDate.now()).execute()
```

We want a list of all titles and their authors. This is what a select query in db-Objekts looks like.
```kotlin
val bookAuthors: List<Tuple2<String, AuthorRow>> =
    tr.select(Book.title, Author).asList()
```
Note that there's no `from` clause. db-Objekts can figure out the necessary joins from the columns provided in `select(..`).

`asList()` terminates the statement and returns a list of type-safe tuples that correspond to the number and types of the columns provided.

You can supply individual columns or an entire table in the select clause (like the `book.*` syntax in native sql). For each `Table` subclass there is a stateful, immutable data class (`AuthorRow` in this case) which contains the values of a specific row. You will later see how you can use these same row objects in update and insert statements.

Let's take it up a notch. This query involves all five tables and returns `List<Tuple5<LocalDate, Long, String, String, String>>`. Since all `Tuple*` classes are data classes, you can deconstruct them into a more readable output

```kotlin
// the type returned is List<Tuple5<LocalDate, Long, String, String, String>>
tr.select(Loan.dateLoaned, Item.id, Book.title, Author.name, Member.name).asList()
  .forEach { (dateLoaned, item, book, author, member) ->
    println("Item $item of $book by $author loaned to $member on $dateLoaned")
    //"Item 1 of Nineteen-eighty Four by George Orwell loaned to John on 2022-12-23"
  }

```

Native SQL queries are also possible, with the convenience of type-safe tuples.
```kotlin
val (id, name, salary, married, children, hobby) =
    tr.sql(
        "select e.id,e.name,e.salary,e.married, e.children, h.NAME from core.employee e left join hr.HOBBY h on h.ID = e.HOBBY_ID where e.name = ?",
        "John"
    ).withResultTypes()
        .long()//refers to employee.id
        .string()//refers to employee.name
        .double()//refers to employee.salary
        .booleanNil()//refers to employee.married
        .intNil()//refers to employee.children
        .stringNil()//refers to hobby.name, possibly null because it's an outer join
        .first()
```

This concludes our bird's eye view of db-Objekts. Check out https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/QueryOverviewComponentTest.kt[QueryOverviewComponentTest] to get you going.

There is much, much more to explore in the following sections, so let's dig in!

== Getting started

=== Installation and configuration
You can get the latest release from https://mvnrepository.com/search?q=com.db-objekts[Maven central]

The following https://github.com/jaspersprengers/db-objekts-demo[stand-alone github project] contains the examples from this section and is a good starting point to get you going.

The main jar is `com.db-objekts:db-objekts-core`, and you also need a vendor-specific implementation. Since the latter depends on core, you need only add the vendor-specific dependency to your maven or gradle file.
```xml
<dependency>
	<groupId>com.db-objekts</groupId>
	<artifactId>db-objekts-mariadb</artifactId>
	<version>...</version>
</dependency>
```

There is no transitive dependency on the appropriate JDBC driver, as this is most likely already on your classpath. If not, you need to add it explicitly.

All you need in a SpringBoot context is to create a Bean for your `TransactionManager`, provided the DataSource is properly configured.
```kotlin
// Call the method something other than transactionManager(), or it will clash with the one in org.springframework.transaction
@Bean()
fun dbObjektsTransactionManager(dataSource: DataSource): TransactionManager {
    return TransactionManager.builder()
        .withDataSource(dataSource)
        .withCatalog(CatalogDefinition)
        .build()
}
```

Now you can inject the `TransactionManager` and you're ready to query. Note: this examples assumes you have already generated the metadata objects (`Employee` in this case), which we'll cover in the next section.
```kotlin
@Service
class DataService(val transactionManager: TransactionManager) {

    fun getEmployeeNames(): List<String> {
        return transactionManager {
            it.select(Employee.name).asList()
        }
    }
}
```

=== Generating metadata objects
Some clarification is in order before we dive into the details of code generation.

Auto-generating code is an established practice. For example, you can create richly annotated interfaces from an `openapi.yaml` file that specify the available REST endpoints and expected messages. By implementing these interfaces you create a compile-time dependency on the generated code.

db-Objekts is similar in that its generated metadata objects become tightly coupled to the business source code. That is a good thing, because the database _is_ already an integral part of the application logic, whatever way you interact with the database. The drawback of using uncompiled, raw SQL is that structural changes to the db go unnoticed unless you have extensive integration tests (unit tests won't catch it). Otherwise, defects pop up only in production. Not good.

When a component implements a service, it often owns the specification (or rather the team does). Such files belong to the source repository and since _you_ manage them, it's fine to re-generate the code whenever you do a fresh build .

A database creation script is similar in purpose to an openapi.yaml file. However, the difference is often one of ownership: your project may not own the db. Even if you keep a dump file in source control and can create a containerized db from it, it matters whether that dump file is the single source of truth. If not, unannounced changes may mess up the status quo. We need a means of validation.

==== Code generation during the development life cycle
Generating code is harmless when there's no application code yet that uses the metadata. But later, it makes sense to compare the current db structure to the generated metadata, before you overwrite it. So keep to the following best practices:

* Always write generated code to a separate source folder, called `gen` or `generated-sources`. Never alter this code manually. All the tweaks you should need are possible through configuration of the `CodeGenerator`.
* Put the generated kotlin sources under version control -- yes, even though they are generated. Remember, the state of the database may not be in your hands.
* Include a regular automated test to validate the database against the generated sources. Validation should take place in the test phase, not the generate-sources phase. See https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-mariadb/src/test/kotlin/com.dbobjekts.mariadb/MariaDBIntegrationTest.kt[MariaDBIntegrationTest] for an example.

=== Code generation in detail
With this in mind, let's have a detailed look at the process. https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/codegen/CodeGenerator.kt[CodeGenerator] is our port of call for the entire process. https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/CodeGenerationComponentTest.kt[CodeGenerationComponentTest] has a comprehensive example.

Configuration consists of the following:

* Mandatory `DataSource`.
* Optional configuration for exclusions.
* Optional configuration for mapping column types to SQL types and using custom types for specific columns
* Optional configuration for setting the sequence names for auto-generated keys.
* Mandatory configuration of the output

==== First steps
We're making the code generation part of the standard test phase and include a component test for it.
```kotlin
class CodeGenerationAndValidationTest {
    @Test
    fun validate(){
       val generator = CodeGenerator()
    }
}
```
First you need to set up the `DataSource`. Make sure the user has sufficient privileges to read the relevant metadata tables (INFORMATION_SCHEMA in MySQL/MariaDB)
```kotlin
   val generator = CodeGenerator().withDataSource(myDataSource)
```
==== Configuring exclusions of tables and columns
Sometimes the database has columns, tables, or even entire schemas that are not relevant to the application's business logic. A typical example are read-only audit columns that are populated by triggers.

We don't want these in the generated code, and here's how you keep them out:
```kotlin
generator.configureExclusions()
      //any column with the string 'audit' in it, in any table or schema
     .ignoreColumnPattern("audit")
     //all 'date_created' columns in any table or schema
     .ignoreColumn("date_created")
     //skip the entire finance schema
     .ignoreSchemas("finance")
     //ignore the table country, but only in the hr schema
     .ignoreTable("country", schema = "hr")
```

NOTE: System schemas per vendor like `sys`, `mysql` or `information_schema` are already ignored. No need to exclude them explicitly.

==== Configuring column mapping
db-Objekts chooses a suitable implementation of https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/metadata/column/Column.kt[Column], depending on the db type (e.g. `CHAR(10)` or `INT(6)`). There is a Column class to represent every possible flavour of values that you can read and write through the JDBC API: all the numeric primitives, booleans, byte arrays and date/time types. But also vendor-specific types are possible, for UUIDs or geographical data. You find them in the https://github.com/jaspersprengers/db-objekts/tree/main/db-objekts-core/src/main/kotlin/com/dbobjekts/metadata/column[metada/column] package.

Sometimes you want to fine-tune this mapping. For example: in  MySQL a `TINYINT(1)` is mapped to a `Byte` by default, but as it is often used as a boolean value (with 1 or 0), it's more convenient to map it to Boolean. Another scenario is when you create a custom type to represent a String value by a business enum, e.g. your own `AddressType`.

db-Objekts iterates through a list of https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/codegen/datatypemapper/ColumnTypeMapper.kt[ColumnTypeMapper] instances. These receive the metadata for a given column in a  https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/codegen/datatypemapper/ColumnMappingProperties.kt[ColumnMappingProperties] object and match it to an appropriate `Column`, or null if the mapping does not apply.

db-Objekts tries you custom mappings in order of registration to find a match, and then defaults to the vendor specific mapping, which has a mapping for every SQL type in the database, like https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-mariadb/src/main/kotlin/com/dbobjekts/vendors/mariadb/MariaDBDataTypeMapper.kt[MariaDBDataTypeMapper]. Do have a look at that file: it will make the mechanism clear.


==== Overriding a column by sql type
Here's how to override the default mapping of `TINYINT` to a numeric type and instead use Boolean.

`setColumnTypeForJDBCType` takes the SQL type and the class of the appropriate Column. `com.dbobjekts.metadata.columnNumberAsBoolean` takes care of converting an Int to Boolean and back.
```kotlin
generator.configureColumnTypeMapping()
   .setColumnTypeForJDBCType("TINYINT(1)", NumberAsBooleanColumn::class.java)
```

==== Overriding a column by name or pattern
db-Objekts lets you write you own Column implementations. This can be useful to:

* Use a business enum instead of an integer or character value, e.g. the `AddressTypeAsStringColumn` which maps to the `AddressType` enum
* Add extra validation or formatting to a column, e.g. a `DutchPostCodeColumn`.
* Cover up poor database design decision, for example a CHAR column which is abused as a Boolean with Ja/Nein.

See the xref:_creating_custom_column_types[advanced section] for details.

```kotlin
generator.configureColumnTypeMapping()
   .setColumnTypeForName(
        table = "EMPLOYEE_ADDRESS",
        column = "KIND",
        columnType = AddressTypeAsStringColumn::class.java)
```
The `AddressTypeAsStringColumn` is a custom specialization of `EnumAsStringColumn<AddressType>`.

=== Setting sequence names
Many vendors support sequences for generating primary keys, but the information schema does not store which sequence is used for which table. So, unfortunately, you have to configure this manually, as follows:
```kotlin
 generator.configurePrimaryKeySequences()
            .setSequenceNameForPrimaryKey("core", "employee", "id", "EMPLOYEE_SEQ")
```
This is fine if you have a small schema, but cumbersome if you have > 100 tables to configure. If you have a consistent naming scheme, you can write your own implementation of `SequenceForPrimaryKeyResolver`
```kotlin
generator.mappingConfigurer()
 .sequenceForPrimaryKeyResolver(AcmeSequenceMapper)

  object AcmeSequenceMapper : SequenceForPrimaryKeyMapper {
        //every column offered is a numeric primary key. No need to check for it yourself
        override fun invoke(properties: ColumnMappingProperties): String? =
            properties.table.value + "_SEQ"
    }
```
==== Output configuration
Whew, that was a lot of information. Don't worry, you're almost done. `CodeGenerator` has everything it needs to produce the right metadata objects. It only needs to know where to put things.

This example points to `src/generated-sources/kotlin` in your project root and creates a package tree `com.dbobjekts.testdb.acme` under it.
In this package will be a `CatalogDefinition.kt` kotlin object with subpackages for each schema, which contain one `Schema` object and a `Table` object for each table in the schema.
```kotlin
generator.configureOutput()
            .basePackageForSources("com.dbobjekts.testdb.acme")
            .outputDirectoryForGeneratedSources(Paths.get("src/generated-sources/kotlin").toAbsolutePath().toString())
```

==== Validate and produce your code
Now you're set to produce your code, like so.
```kotlin
generator.generateSourceFiles()
```
If all is well, you now have a bunch of files and packages under the designated source folder, ready to be used for querying.

However, after you have done your first code generation run, we need to build in validation to ensure there are no unexpected db changes in the future. So, we want to do a dry-run of the generated code regularly and compare the output to the current state of the metadata. If there are no differences there is no point to overwrite the generated source files. And if there _are_ differences you probably want to inspect them first. Here's how you create the diff we need.
```kotlin
val diff: List<String> = generator.differencesWithCatalog(CatalogDefinition)
assertThat(diff).describedAs("acme catalog differs from database definition").isEmpty()
```
`differencesWithCatalog` takes the target `CatalogDefinition` that would normally be overwritten, and for each detected difference with the current status quo of the db structure, a line is added to the output. So, if the employee table suddenly has a non-null column `shoe_size` added to it, the test will fail with `DB column EMPLOYEE.SHOE_SIZE not found in catalog`.

If you know the changes, you can generate the catalog again and make appropriate changes to the application code, because now the `Employee` metadata object has an extra mandatory column and calls to `mandatoryColumns` will have compiler errors.

Or would you rather fix it in production?

== Querying
The next section will be all about writing queries. For that, you need a reference to a `TransactionManager`.

=== The TransactionManager and Transaction
We already met the `TransactionManager` briefly. It provides access to your database and contains a `javax.sql.DataSource`. A datasource manages connections to the db-server, logging in, pooling and supplying short-lived `javax.sql.Connection` objects to execute the low-level JDBC calls. All these details are hidden from view. Live connections are represented by a `Transaction`. This is the object on which you create the queries.

You only need a single `TransactionManager` for each `DataSource` per application, so it makes sense to create it centrally and make it available through dependency injection. Since a `TransactionManager` is stateless, there is no harm in assigning it to a singleton: different threads can use the same instance.

==== Creating a TransactionManager
The static call to `TransactionManager.builder()` returns a builder with two configuration methods, for the `CatalogDefinition` and the `DataSource`.
```kotlin
val transactionManager = TransactionManager.builder()
    .withCatalog(CatalogDefinition)
    .withDataSource(someDataSource)
    .build()
```
You must always supply a `DataSource`. The catalog is mandatory if you query with metadata objects, and optional if you only use native sql queries.

There is a third, optional method if you want complete control over the way `Connection` objects are obtained from the `DataSource`: `withCustomConnectionProvider`. You can use it as follows:
```kotlin
   .withCustomConnectionProvider { ds: DataSource ->
                    val conn = ds.connection
                    conn.autoCommit = autoCommit
                    conn
                }
```
In this example you override the default setting for autocommit, which is usually configured at the level of the DataSource.

==== The Transaction lifecycle
Every query against db-Objekts is executed through a call to `TransactionManager.newTransaction` or its shortcut `invoke` method. This takes a lambda that receives a fresh `Transaction` object. In the body of the lambda you execute one or more queries and return a result. The `TransactionManager` then commits the underlying `Connection` and returns the result that was returned by the lambda.
```kotlin
val verboseForm: List<BookRow> = tm.newTransaction { tr: Transaction -> tr.select(Book).asList() }
val shortForm: List<BookRow> = tm { it.select(Book).asList() }
```

If the lambda threw an Exception, the connection is rolled back. The effect depends on the autocommit setting of the session (some data may have been successfully persisted). You can find a comprehensive example in https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/TransactionLifeCycleComponentTest.kt[TransactionLifeCycleComponentTest].

The `Transaction` is a short-lived object that should not leave the scope of its lambda. Never assign it to a variable outside that scope. Its lifecycle is no longer be managed and the underlying `Connection` will go stale.

Let's explore the query methods of the `Transaction`: inserting, updating, deleting, selecting and native sql. Do look at the component tests, which are linked in every section and act as living documentation.

For the next examples we have a more meaty test database which has tables spread over a `core` and `hr` schema and two many-to-many columns to link employees to addresses and departments and distinguish work and home addresses in the `employee_address.kind` column.

image:acme-datamodel.png[]]

=== Inserting data
The `insert(..)` method takes a `Table` implementation and returns a corresponding builder instance on which to set values. https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/InsertStatementComponentTest.kt[InsertStatementComponentTest]

The insert builders contain setter methods for all columns. In addition, it has a handy `mandatoryColumns(..)` shortcut (provided the table has at least one non-nullable column) to make sure you provide all the required values.

```kotlin
  transaction.insert(Country).mandatoryColumns("nl", "Netherlands").execute()
  val petesId: Long = transaction.insert(Employee)
      .mandatoryColumns("Pete", 5020.34, LocalDate.of(1980, 5, 7))
      .married(true)
      .execute()
```

- The `Country` object has two mandatory columns and no auto-generated key. The `execute()` method returns the value of the JDBC call `PreparedStatement.executeUpdate()`, which should be 1 for a successful insert.
- The `Employee` table has four mandatory columns. The optional `married` property is set in a setter method. The table has a generated primary key, which is returned by the `execute()` method.

==== Inserting a stateful row data object
For each stateless Kotlin object that represents a db table there is also a corresponding stateful, immutable data class to represent a single row of data, called `__Table__Row` They are most useful for retrieving all columns in a table, but you can also use them to insert data.
```kotlin
val row = EmployeeRow(
    name = "John",
    salary = 300.5,
    married = true,
    dateOfBirth = LocalDate.of(1980, 3, 3),
    children = 2,
    hobbyId = "chess"
)
val johnsId = tr.insert(row) //immediately executes and returns the auto-generated ID
```
It's your own responsibility to make sure all the mandatory columns have non-null values.

NOTE: This you must know auto-generated primary keys. `EmployeeRow` has a non-null `id` field, which is auto-generated hence unavailable until after the `insert(...)` call. We __could__ define such numeric PKs as `Long?` or `Int?`, but that would mean ugly `!!` usage when the id is guaranteed never to be null. The compromise is to provide a default value of zero. You don't specify the ID in `EmployeeRow` yourself, and for the insert logic, it is ignored anyway.

=== Basic select statements
Let's move on to select statements now. The pattern is `transaction.select( col1, col2, ... ).where( conditions ).[first[orNull]()|asList()]`.

You start with listing the columns and tables you want to retrieve, the where clause and then retrieve a list of results. See https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/SelectStatementComponentTest.kt[SelectStatementComponentTest]

This query selects name and salary for all rows in the employee table. Notice we have imported the 'e' alias from the generated https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/generated-sources/kotlin/com/dbobjekts/testdb/acme/Aliases.kt[Aliases] object. This is a handy shortcut that refers to the exact same Employee object.
```kotlin
 val asList: List<Tuple2<Long, String>> = it.select(e.id, e.name).asList() // potentially empty
 val asOption: Tuple2<Long, String>? = it.select(e.id, e.name).firstOrNull() // None if no row can be retrieved
 val singleResult: Tuple2<Long, String> = it.select(e.id, e.name).first() //Will throw an exception if no row can be found
```

The result is always a Tuple* object that corresponds in size and type to the columns you specified in the `.select(..)` call.

The `Employee` and `Address` tables are linked via the `EmployeeAddress` table in a many-to-many fashion. Since the foreign key relations are explicit in the source code, db-Objekts can build the joins for you:

```kotlin
  transaction.select(e.name, e.dateOfBirth, e.children, e.married).where(Address.street.eq("Pete Street")).asList()
```

We can select from the `Employee` table with a constraint on the `Address` table, without specifying the join! This mechanism saves you a lot of typing, but comes with limitations:

* There must be an explicit foreign-key relationship between the tables used in your statement, or there must be a many-to-many join table that links two tables referred in your query, like in the above example.
* By default, joins are inner joins. Using outer joins is possible, but comes with some caveats, so it has a xref:_outer_joins_and_more_customization[dedicated section].

In a call like `select(Employee.name, Country.name)` db-Objekts cannot figure out that it needs `address` and `employee_address`. In that case you need to specify the joins manually. Call the `from(SomeTable)` method with the driving table of your selection, and add the tables to joined as follows:

```kotlin
 transaction.select(e.name, c.name)
      .from(Employee.innerJoin(ea).innerJoin(Address).innerJoin(Country))
      .where(ea.kind eq "WORK").asList()
```

The table provided in the `innerJoin()` must have an explicit foreign key relationship with its parent. This resolves to the following SQL (we'll look at left/right outer joins later).

```sql
 FROM EMPLOYEE e JOIN EMPLOYEE_ADDRESS ae on e.id = ae.employee_id JOIN ADDRESS a on a.id = ae.address_id join COUNTRY c on c.id = a.country_id
```

`asList` always return a (potentially empty) list of results. If one row is all you need, you can invoke `first()` or the safer option `firstOrNull()`, since the former will throw if the resultset was empty.

When you execute a select statement, db-Objekts pulls all results into a list structure, which add to the JVM heap. This may not be what you want.
The `forEachRow()` call lets you inspect the Resultset row by row through a custom predicate so you can decide how to handle them and even abort further retrieval, which means reduced traffic from the RDBMS to your application.
```kotlin
  val buffer = mutableListOf<String?>()
    transaction.select(e.name).orderAsc(e.name).forEachRow({ row ->
    buffer.add(row)
    //there are three rows in the resultset, but we stop fetching after two
    buffer.size != 2
})
```

You can further tweak select results with the `orderBy` and `limit(..)` methods. This orders all employees by salary (highest first), then by name (A-Z), and retrieves the first ten rows.
Note that these constraints are executed server-side, as they are part of the SQL. db-Objekts takes care of the proper syntax, because vendors handle the limit clause differently.

```kotlin
  tr.select(e.name).orderDesc(e.salary).orderAsc(e.name).limit(10).asList()
```

=== Outer joins and more customization
Recall the previous query `tm.select(Employee.name, Hobby.name)`, which does an inner join and only returns results where a `hobby` record is linked to an `employee`. If we want all employee records, what we need is a left outer join. There are two basic options.
```
tr.select(Employee.name, Hobby.name).useOuterJoins()
tr.select(Employee.name, Hobby.name).from(Employee.leftJoin(Hobby))
```
The method `useOuterJoins` is an instruction to use left outer joins for every table involved. The other option is to build the join chain yourself, which gives you greater control when there are more tables involved. Maybe not everything should be an outer join.

But the above code will run into trouble! Do you see it? `Hobby.name` is an instance of a non-nullable `VarcharColumn`, which demands a String data type, but when there are no matches, it gets a null back from the database and slaps you with an exception, because the query returns `Tuple2<String,String>` and cannot put a null in the second `String`.

The fix is to use the nullable counterpart if a non-null column can be null as the result of an outer join. Each non-nullable column implementation has a `nullable` counterpart, and it's there for exactly this purpose. Now the return type of the query will be `Tuple2<String,String?>`.
```kotlin
tr.select(Employee.name, Hobby.name.nullable).useOuterJoins()
```

=== The where-clause in details
Update, select and delete are executed against a range of database rows that satisfy certain criteria. These criteria are expressed in the where-clause.

The canonical form of the where clause is `statement.where(column .. operator .. [value, otherColumn] [and|or] ... )` which is quite analogous to normal SQL usage.

```kotlin
 where(Employee.name.eq("Janet"))
 where(Employee.dateOfBirth.gt(LocalDate.of(1980,1,1)))
```
These are the operators you can use.

- `eq`: is equal to
- `ne`: is not equal to.
- `gt`: is greater than.
- `lt`: is less than.
- `gte`: is greater than or equal.
- `lte`: is less than or equal.
- `within`: is within a range of values.
- `notIn`: is not within a range of values.
- `startsWith`: (for character type only)
- `endsWith`: (for character type only)
- `contains`:  (for character type only)
- `isNull`
- `isNotNull`

You can chain conditions using `and` or `or` and you can even build nested conditions:

```kotlin
  where(e.married.eq(true)
      .or(
          e.name.eq("John").or(e.name).eq("Bob"))
        ) // all married people, plus John and Bob
```

If you have no conditions to constrain your selection you can omit the where clause: `tr.select(Book).asList()`

=== Updating
The `update(..)` method, like the `insert(..)`, takes a table and returns an `*UpdateBuilder`. See https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/UpdateStatementComponentTest.kt[UpdateStatementComponentTest]

```kotlin
 transaction.update(Employee)
     .salary(4500.30)
     .married(null)
     .where(e.id.eq(12345))
```

- You can provide a null to a setter method if the corresponding database column is nullable: `update(Employee).married(null)`.
- Note that you cannot do that with `salary`, because it is non-nullable: `.salary(null)` will not compile
- The call to `where(...)` is always mandatory as it terminates the statement and executes it. If you want to update all rows, use the no-arg version `where()`
- If your vendor supports it, you can involve other tables in the where clause: `tr.update(Employee)[..].where(Hobby.name.eq("chess))`. H2 does not support it.

==== Updating with a stateful row data object
You can use the data row objects to perform updates, but conditions apply. db-Objekts can only manage it if the Table has _one_ designated primary key, because it constructs a clause `where(Table.id.eq(pk))`. Let's give John a well-earned raise:
```kotlin
val retrieved: EmployeeRow = tr.select(Employee).where(Employee.id.eq(johnsId)).first()
tr.update(retrieved.copy(salary = retrieved.salary + 100))
```
The row data object retrieved is immutable, so we need to make a copy with an updated salary field. Note that data rows in db-Objekts are very different from managed entities in ORM.

=== Deleting
The statement to delete rows has the fewest options. See https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/DeleteStatementComponentTest.kt[DeleteStatementComponentTest]
```kotlin
tr.deleteFrom(Employee).where(Employee.id.eq(id))
```
* The `deleteFrom` method takes a single table or a join (not all vendors supports it). `tm { it.deleteFrom(e.innerJoin(Hobby)).where(h.name.eq("chess")) }`
* The call to `where(...)` is always mandatory. If you want to delete all rows, use the no-arg version: `tr.deleteFrom(Employee).where()`


=== Custom sql queries
db-Objekts does not set out to cover all your select, insert, update and delete query needs. That is a deliberate design decision. It aims to make mundane queries more pleasant and safe, but recognizes that sometimes native SQL makes more sense. See https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/CustomSQLComponentTest.kt[CustomSQLComponentTest]

You can still execute nativeSQL through the TransactionManager and enjoy type-safe results. There are two flavors: queries that return results and those that don't. Let's tackle the latter first.

```kotlin
 tr.execute("CREATE SCHEMA if not exists core")
```
`Transaction.execute` takes a String of SQL and a vararg of arbitrary parameters. The length must match the number of `?` placeholders in the query.
```kotlin
 tr.execute("update core.employee where e.name=?", "john")
```
That was too easy. Let's move up to statements that retrieve results.

```kotlin
val (id, name, salary, married, children, hobby) =
    it.sql(
        "select e.id,e.name,e.salary,e.married, e.children, h.NAME from core.employee e join hr.HOBBY h on h.ID = e.HOBBY_ID where e.name = ?",
        "John"
    ).withResultTypes().long().string().double().booleanNil().intNil().stringNil()
        .first()
```

The `sql` method on `Transaction` works the same as regular select statements when it comes to retrieving parameterized tuples. But instead of providing that information through a list of ColumnClasses, you do it in a call to `withResultTypes`.

This returns a builder with methods for each available standard SQL type in a nullable and non-nullable flavour. String together all the methods you need, call `first[orNull]()`, or `asList()`, and the output of the custom query will be returned in a type-safe tuple.

image::custom_sql.png[autocomplete_update, 600]

But wait, there are more goodies. Wouldn't it be great if you could employ the same custom column types that you created for your metadata-based queries in native SQL? You can, with the `custom(..)` builder method.

This method comes in the same nullable and non-nullable flavors and takes a reference to the appropriate Column class. Suppose the following query selects two columns which are stored as TINYINT(1) used as a Boolean, and VARCHAR(10) nullable, respectively. We want to read them out as Boolean and our own AddressType.

```kotlin
val rows: List<Tuple2<Boolean, AddressType?>> = it.sql(
    "select e.has_children,e.address_type from EMPLOYEE e"
).withResultTypes()
    .custom(NumberAsBooleanColumn::class.java)
    .customNil(NullableAddressTypeAsStringColumn::class.java)
    .asList()
```

Static objects `com.dbobjekts.metadata.column.[Nil]ColumnClasses` gives a handy overview, so you could also write:
```kotlin
.custom(ColumnClasses.NUMBER_AS_BOOLEAN)
```
The `custom` and `customNil` methods take a `NonNullableColumn` and `NullableColumn` reference, respectively. You can't go wrong there, as mismatches won't compile.

== Advanced topics

=== The db-Objekts metadata model
db-Objekts creates three main types  of metadata that correspond to the database schema:

* A single `CatalogDefinition` object with reference to one or more Schemas and a specification of the vendor type.
* A `Schema` object for each schema in the Catalog.
* One or more `Table` objects for each table in the schema.

Starting with https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/generated-sources/kotlin/com/dbobjekts/testdb/acme/CatalogDefinition.kt[CatalogDefinition]:

```kotlin
object CatalogDefinition : Catalog("H2", listOf(Core, Hr, Library))
```

the Library schema
```kotlin
object Library : Schema("LIBRARY", listOf(Author, Book, Item, Loan, Member))
```
and the `Book` table (omitting the stuff that's only for internal use)
```kotlin
object Book:Table("BOOK"){
    val isbn = com.dbobjekts.metadata.column.VarcharColumn(this, "ISBN")
    val title = com.dbobjekts.metadata.column.VarcharColumn(this, "TITLE")
    val authorId = com.dbobjekts.metadata.column.ForeignKeyLongColumn(this, "AUTHOR_ID", Author.id)
    val published = com.dbobjekts.metadata.column.DateColumn(this, "PUBLISHED")
}
```
All that is needed to create queries is expressed in the column types: how to create primary keys (auto generated, with a sequence, or manually), whether a type is nullable, and the parent table/column for primary keys.

=== Creating custom column types
The power of db-Objekts is that you can fully customize the way values are read from and written to the database. For this we need to dig deeper in the `Column` hierarchy.

Abstract `com.dbobjekts.metadata.column.Column<T>` is at the basis and has only two direct abstract descendants: `NonNullableColumn<T>` and `NullableColumn<T>`, parameterized for a certain value type. Implementations must override
```kotlin
 abstract fun getValue(position: Int, resultSet: ResultSet): I?
 abstract fun setValue(position: Int, statement: PreparedStatement, value: I)
```
`getValue` deals with `ResultSet`, `setValue` with `PreparedStatement`. For the concrete class `VarcharColumn`, this looks as follows:
```kotlin
override fun getValue(position: Int, resultSet: ResultSet): String? = resultSet.getString(position)
override fun setValue(position: Int, statement: PreparedStatement, value: String) = statement.setString(position, value)
```
Notice that `getValue` must always return a nullable result, also for `NonNullableColumn`, because getter calls on a `ResulSet` can return null. The base class will cast it to a non-nullable value: you never directly invoke `getValue`.

The JDBC getter and setter methods cover all the Java primitives, including dates, string, blobs and other esoteric types. For each of these there is a suitable implementation in `com.dbobjekts.metadata.column`, with a companion `Nullable*Column`.

For numeric types we have, from small to large
|===
|Column class  |value class

|ByteColumn
|Byte

|ShortColumn
|Short

|IntegerColumn
|Int

|LongColumn
|Long

|FloatColumn
|Float

|DoubleColumn
|Double

|BigDecimalColumn
|java.math.BigDecimal

|===

Then there is String and Boolean

|===
|Column class  |value class

|VarcharColumn
|String

|BooleanColumn
|Boolean

|===

Byte arrays and large objects:

|===
|Column class  |value class

|BlobColumn
|java.sql.Blob

|ByteArrayColumn
|ByteArray

|ClobColumn
|Clob

|===

Date and time columns

|===
|Column class  |value class

|DateColumn
|java.time.LocalDate

|DateTimeColumn
|LocalDateTime

|OffsetDateTimeColumn
|java.time.OffsetDateTime

|TimeColumn
|java.time.Time

|TimeStampColumn
|java.time.Instant

|===

And a number of utility columns, most of them abstract, to serve as a basis for custom extensions.

|===
|Column class  |value class|abstract?

|EnumAsIntColumn
|Enum stored by its `ordinal()` as an Int
|Yes

|EnumAsStringColumn
|Enum, stored by its `name()` as a String
|Yes

|ObjectColumn
|Any
|Yes

|NumberAsBooleanColumn
|Boolean stored as an Int 0/1
|No

|===

==== Customizing EnumAsString with AddressTypeColumn
Suppose we have the following `AddressType` enum:

```kotlin
enum class AddressType : Serializable {
    HOME, WORK
}
```

To make a compliant Column, you need to override `EnumAsStringColumn<AddressType>`. Unless you are absolutely positive that the value can never be null, you need to provide a Nullable counterpart as well:
```kotlin
class AddressTypeAsStringColumn(table: Table, name: String) : EnumAsStringColumn<AddressType>(table, name, AddressType::class.java) {
    override val nullable = NullableAddressTypeAsStringColumn(table, name)
    override fun toEnum(name: String): AddressType = AddressType.valueOf(name)
}
class NullableAddressTypeAsStringColumn(table: Table, name: String) :
    NullableEnumAsStringColumn<AddressType>(table, name, AddressType::class.java) {
    override fun toEnum(name: String): AddressType = AddressType.valueOf(name)
}
```
You need to signal the `CodeGenerator` where this custom column applies, and then you can use it.
```kotlin
generator.configureColumnTypeMapping()
    .setColumnTypeForName(table = "EMPLOYEE_ADDRESS", column = "KIND", columnType = AddressTypeAsStringColumn::class.java)

tr.insert(EmployeeAddress)
    .mandatoryColumns(employeeId = 43,
        addressId = 42,
        kind = AddressType.WORK)
    .execute()
```

==== Customizing ObjectColumn for UUIDs
H2 supports a data type for storing UUIDs (universally unique identifiers), which has no JDBC counterpart. To read and retrieve `java.util.UUID`, you extend `ObjectColumn`.
```kotlin
package com.dbobjekts.vendors.h2
import java.util.UUID
class UUIDColumn(table: Table, name: String) : ObjectColumn<UUID>(table, name, UUID::class.java) {
    override val nullable: NullableColumn<UUID?> = NullableUUIDColumn(table, name)
}
class NullableUUIDColumn(table: Table, name: String) : NullableObjectColumn<UUID?>(table, name, UUID::class.java) {
}
```
There's nothing to override other than the `nullable` property. `UUIDColumn` is only there to fill in the `<T>`. The base class takes care of calling `getObject(..)` on the `ResultSet`.

==== Customizing SerializableColumn

Sometimes it would be good to have some extra validation. Suppose we want to make sure only valid Dutch postcodes are stored in `Address.postcode`. See the full example in `com.dbobjekts.testdb.DutchPostCodeColumn`.

You extend from a regular `VarcharColumn`, but add some extra validation of your own.
```kotlin
class DutchPostCodeColumn(table: Table, name: String) : VarcharColumn(table, name) {

override fun setValue(position: Int, statement: PreparedStatement, value: String) {
        validate(value)
        super.setValue(position, statement, value)
    }

    companion object {
        val pattern = Pattern.compile("^\\d{4}[A-Z]{2}$")
        fun validate(postcode: String) {
            if (!pattern.matcher(postcode).matches())
                throw IllegalStateException("$postcode is not a valid Dutch postcode.")
        }
    }
}
```

=== Security concerns
Much sensitive data flows through a database library like db-Objekts, so we take security seriously. And so should you! The following design decisions and principles are in place:

* db-Objekts never logs concrete data that is read or written to the db tables. It keeps such data in-memory for debugging purposes in an [ExecutedStatementInfo] data class only for the duration of a single `Transaction`, after which it is cleared.
* All generated statements use placeholder `?` syntax to guard against SQL injection attacks. You should still be careful to sanitise end-user data before you pass them as parts of a query, like in `tr.select(Employee).where(e.name.eq(someValueFromRestCall))`
* This warning applies especially to custom sql statements, for which db-Objekts cannot provide similar safeguards.

== Status and roadmap
db-Objekts has been a long time in the making. I started it in Scala, but switched to Kotlin because its null-safety is perfectly suited to the world of (relational) data. For several years it remained a hobby project and was not mature enough to become the Open Source tool I had in mind. But that time has now come.

This is the very first alpha release. The API may change slightly, so it is not yet ready for a beta release and you should not use it in production yet. While I'm confident and proud of my work, more rigorous testing is needed.

=== Roadmap

* From Januari 2023 a number of alpha releases will cover the following
**  Close to 100% unit test coverage
** Full coverage for all column types in the H2 database, used for testing
** Improving and cleaning up source code documentation and user docs
** Minor alterations the API with regard to method names and possible refactoring of packages

* The beta release planned for spring 2023 will cover:
** Addition of PostgreSQL and MySQL as vendor types
** Rigorous integration tests on dockerized images of all database vendors as part of the build
** No more API changes are to be expected.
