:toc:

= Introduction
:imagesdir: ./docs

NOTE: db-Objekts is currently in alpha. The API is still subject to change and is not production ready. During the alpha release it will only support MariaDB.
The plan is to release a beta early 2023 followed by a first release later that year. This release will support MySQL, PostgreSQLS and Oracle. See <<_status_and_roadmap>> for the planning

== Fluent, type-safe, lightweight and opinionated
db-Objekts is a Kotlin library to perform queries on a relational databases in application code.
It generates source code that acts as metadata for all tables, columns and foreign keys. You then use these stateless Kotlin objects to build type-safe and fluent queries, comfortably using
your IDE's autocomplete, while db-Objekts takes care of the SQL boilerplate and type conversions.

The project was conceived and built by me, Jasper Sprengers, a software developer living in the Netherlands.

db-Objekts has some conceptual similarities to object relational mapping frameworks like Hibernate, but is also quite different. ORMs work with stateful entities that abstract away the database layer, even the individual tables. They are certainly not lightweight of easy to master well. db-Objekts is firmly focused on executing queries on tables, but these tables have become part of your application's source code. This gives you all the benefits of your IDE's auto-complete features, in addition to Kotlin's type and null-safety.

Let's start with an overview of features.

== A bird's eye feature view
Let's showcase the features in a concise demonstration to get a feel of what you can achieve with db-Objekts.

We have a simple database of a lending library with five tables
* `author` represents a person, with name, bio, and data of birth.
* `book` has the official isbn as its primary key, a title, year of publication and a reference to its author.
* `item` represents a physical copy of a book. It refers to the `book` table and stores the date of acquisition. There can be zero or more copies of a book title.
* `member` only stores the name of an invdividual member
* `loan` keeps a record of all the books (items) taken out by a member. It refers to `item` and `member` and keeps the date taken out and returned.

image::datamodel.png[datamodel,600]

First we need metadata objects for our database. For this we need the `CodeGenerator`
```kotlin
val generator = CodeGenerator()
       .withDataSource(datasource = H2DB.dataSource)
generator.outputConfigurer()
        .basePackageForSources("com.acme.db-Objekts")
        .outputDirectoryForGeneratedSources(Paths.get("src/gen/kotlin").toAbsolutePath().toString())
generator.generateSourceFiles()
```

This is a bare-bones setup. There is much more to fine-tune. This writes metadata objects under the package `com.acme.db-Objekts` in a special `gen` source folder, which indicates you should not manually alter these files.

The next step is to configure the `TransactionManager`. This wraps a `javax.sql.DataSource` and acts as a factory for transactions.
You typically only need one instance per database. This example is for an embedded H2 database, taken from the project `com.db-Objekts.sampledbs.h2.H2DB`
The code generation stage produced a `AcmeCatalog` Kotlin `object`. dbo needs this to produce SQL boilerplate specific to our schemas.
```kotlin
val dataSource = HikariDataSourceFactory.create(url = "jdbc:h2:mem:test", username = "sa", password = null, driver = "org.h2.Driver")
val transactionManager = TransactionManager.builder()
    .withCatalog(TestCatalog)
    .withDataSource(dataSource).build()
```

To get a connection from the `TransactionManager` and start performing queries, use the following syntax (we'll use `tm` for `TransactionManager` instances and `tr` for `Transaction` throughout this tutorial)
```kotlin
val resultOfQuery = tm.newTransaction { tr->
    //execute your query/queries here
}
```
The `newTransaction()` method's signature is `fun <T> newTransaction(function: (Transaction) -> T): T`. You provide it with a lambda that takes a `Transaction` and can produce any result. The `invoke()` operator does the same, so you can express it even more concisely:
```kotlin
val books: List<String> = tm { it.select(Book.isbn).asList() }
```

That was our very first query: select the ISBN column from the `book` and return it as a `List<String`. Now let's add an author, title and member.
The `mandatoryColumns(..)` call is a convenience method to make sure you don't miss any of the non-null columns in your insert.
When the table in question has an auto-generated id, it is returned as a `Long`. We need to store it for later.
```kotlin
val orwell: Long = tr.insert(Author).mandatoryColumns("George Orwell").execute()

// the primary key of the book table is not auto-generated. In this case execute() returns 1.
tr.insert(Book).mandatoryColumns("ISBN-1984", "Nineteen-eighty Four", orwell, LocalDate.of(1948,1,1)).execute()

val john = tr.insert(Member).mandatoryColumns("John").execute()
```
We forgot to put a bio for George Orwell. Let's do that now. Notice the use of the where clause. Common sql operator symbols (=,<,>,!=) have textual counterparts.
And yes, you can do embedded and/or conditions. More on that later.
```kotlin
  tr.update(Author)
      .bio("(1903-1950) Pseudonym of Eric Blair. Influential writer of novels, essays and journalism.")
      .where(Author.id.eq(orwell))
```
Notice the power of autocomplete here. You instantly know which columns are available, which types they take, and whether null values are allowed.

image::autocomplete_update.png[autocomplete_update, 600]

image::autocomplete_insert.png[autocomplete_insert, 600]

Add a physical copy and then we have all the data to loan out the book
```kotlin
//we have two copies of Harry Potter, one of 1984 and we misplaced the one of the Road to Wigan Pier.
val copy1984 = tr.insert(Item).mandatoryColumns("ISBN-1984", LocalDate.of(1980,5,5)).execute()

tr.insert(Loan).mandatoryColumns(memberId = john, itemId = copy1984copy1984, dateLoaned = LocalDate.now()).execute()
```

Now we can start querying. Let's get a list of all titles and their author data. This is what a select query in dbo looks like. You will notice that there is no `from` clause. All the information is present in the column references that you provide in the call to `select(..`) and dbo is can figure out the necessary table joins. The terminating `asList()` call returns a list of type-safe tuples that correspond exactly to the number and types of the columns in the `select(..)` call. Notice that `Author.bio` is a nullable column. Hence, the corresponding value in the tuple is `String?`, not `String`.
```kotlin
val bookAuthors: List<Tuple3<String, String, String?>> = tr.select(Book.title, Author.name, Author.bio).asList()
```
Let's take it up a notch! This query involves all five tables and returns `List<Tuple5<LocalDate, Long, String, String, String>>`. Since all `Tuple*` classes are data classes, you can deconstruct them into a more readable output
```kotlin
tr.select(Loan.dateLoaned, Item.id, Book.title, Author.name, Member.name).asList()
  .forEach { (dateLoaned, item, book, author, member) ->
    println("Item $item of $book by $author loaned to $member on $dateLoaned")
  }
 // the type returned is List<Tuple5<LocalDate, Long, String, String, String>>
 //Item 1 of Nineteen-eighty Four by George Orwell loaned to John on 2022-12-23
```
This concludes our bird's eye view of dbo. You can find the above code in `com.dbobjekts.component.LibraryComponentTest`. That should get you going.

There is much, much more to explore in the following sections, so let's dig in!

== Getting started


=== Installation and configuration
You can get the latest release from https://mvnrepository.com/search?q=com.db-objekts[Maven central]

The main jar is `com.db-objekts:db-objekts-core`, but you also need a vendor-specific implementation, which includes the core jar. Include it in you maven or gradle build:
```xml
<dependency>
	<groupId>com.db-objekts</groupId>
	<artifactId>db-objekts-mariadb</artifactId>
	<version>...</version>
</dependency>
```

`DataSource` and  an appropriate JDBC driver are not inherited from db-objekts, as these should be already on the classpath.

All you need in a SpringBoot context is to create a Bean for your `TransactionManager` (provided the DataSource is already configured):
```kotlin
// Call the method something other than transactionManager(), or it will clash with the one in org.springframework.transaction
@Bean()
fun dbObjektsTransactionManager(@Autowired dataSource: DataSource): TransactionManager {
    return TransactionManager.builder().withDataSource(dataSource).withCatalog(CatalogDefinition).build()
}
```

Now you can inject the `TransactionManager` and you're ready to query. Note: this examples assumes you have already generated the metadata objects (`Employee` in this case), which we'll cover in the next section.
```kotlin
@Service
class DataService(val transactionManager: TransactionManager) {

    fun getEmployeeNames(): List<String> {
        return transactionManager {
            it.select(Employee.name).asList()
        }
    }
}
```

=== Generating metadata objects
Before we dive into the details of code generation, some clarification is in order.

Auto-generating code is an established practice since the days of WSDL. You can create richly annotated interfaces from an `openapi.yaml` file that specify the available REST endpoints and expected messages. By implementing these interfaces you create a compile-time dependency on the generated code.

dbo is similar in that regard: the generated metadata objects that stand for the tables and columns become tightly coupled to your source code. That is a good thing, because the database _is_ already an integral part of the application logic, also if you interact through native SQL. The drawback is only that structural changes to the schemas will go unnoticed unless you have strong integration tests (unit tests won't catch it). If not, you notice the defects only in production.

When a component implements a service, it often also owns the specification, or rather the team does. Such files will be part of the source repository. Since _you_ manage them, it's fine to re-generate the code whenever you do a fresh build, during the generate-sources phase, which takes place before compilation. The big difference with an external database is one of ownership: your project may not own the database structure. In the worst case, unannounced changes may mess up the status quo. We need more validation.

==== Code generation and validation during the SDLC
Generating code is harmless when you're starting out with dbo, since there's no source code that uses the new objects. But later, when changes to the structure are carried out, it makes sense to inspect these changes before overwriting anything. So stick to the following:

* Always write generated code in a separate source folder, called `gen` or `generated-sources`. This is a reminder that you should never manually change this code.
* Put the generated kotlin sources under source control, even when they are generated. Remember, the state of the database may not be part of the same versioned repository.
* Include an automated test as part of the build to validate the database against the generated sources. See https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-mariadb/src/test/kotlin/com.dbobjekts.mariadb/MariaDBIntegrationTest.kt[MariaDBIntegrationTest] for an example

=== Code generation in detail
With these warnings in mind, let's have a detailed look at the process. https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/codegen/CodeGenerator.kt[CodeGenerator] is our port of call for the entire process and you can check out https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/AcmeCatalogCodeGenComponentTest.kt[AcmeCatalogCodeGenComponentTest] for a comprehensive example.
Configuration is grouped into the following sections:

* The mandatory javax.sql.DataSource.
* Configuration for exclusions.
* Configuration for mapping column types to SQL types, using custom type for certain columns
* Configuration for setting the sequence names for auto-generated keys.
* Configuration of the output: the folder to write to and the base package structure to use, e.g. `com.acme.dbmetadata`.

==== First steps
Taking the advice to heart, we're making the code generation part of the standard test phase and include a component test for it.
```kotlin
class CodeGenerationAndValidationTest {
    fun validate(){
       val generator = CodeGenerator()
    }
}
```
First you need to set up the `DataSource`. Make sure the user has sufficient privileges to read the relevant metadata tables (INFORMATION_SCHEMA in MySQL/MariaDB)
```kotlin
   val generator = CodeGenerator().withDataSource(myDataSource)
```
==== Configuring exlusions of tables and columns
Sometimes the database has columns, tables, or even entire schemas that are not relevant to the application's business logic. A typical example are read-only audit columns that are populated by triggers.

We don't want these in the generated code, and here's how you do that:
```kotlin
generator.configureExclusions()
      .ignoreColumnPattern("audit")//any column with the string 'audit' in it, in any table or schema
      .ignoreColumn("date_created")//all 'date_created' columns in any table or schema
      .ignoreSchemas("finance")//skip the entire finance schema
      .ignoreTable("country", schema = "hr")//ignore the table country, but only in the hr schema
```
==== Configuring column mapping
dbo chooses a suitable implementation of https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/metadata/column/Column.kt[Column], depending on the db type (e.g. `CHAR(10)` or `INT(6)`). Sometimes you want to fine-tune this mapping. The MySQL type `TINYINT(1)` is mapped to a `Byte` by default, but as it is often used as a boolean value, you can choose to map it to a `BooleanColumn`.

The mechanism offered by dbo is to iterate through a list of `com.dbobjekts.codegen.datatypemapper.ColumnTypeMapper` instances, which is a functional interface that receives all the metadata you need for a given column in a  `ColumnMappingProperties` object in order for the implementation to return an appropriate `Column`, or null if the mapper does noet apply. dbo tries you custom mappings in order of registration to find a match, and then defaults to the vendor specific mapping, which has a mapping for every SQL type in the database.

Let's look at the options

==== Overriding a column by sql type
As mentioned above, here's how you override the default mapping of `TINYINT` to a numeric type and instead use Boolean.

The convenience method `setColumnTypeForJDBCType` takes the SQL type and the class of the appropriate Column. `com.dbobjekts.metadata.columnNumberAsBoolean` takes care of converting an Int to Boolean and back.
```kotlin
generator.configureColumnTypeMapping()
   .setColumnTypeForJDBCType("TINYINT(1)", NumberAsBooleanColumn::class.java)
```

==== Overriding a column by name or pattern
dbo lets you write you own Column implementations, which can be used for:

* Using a business enum instead of an integer or character value, e.g. the `AddressTypeAsStringColumn` which maps to the `AddressType` enum
* Adding extra validation or formatting to a column, e.g. a `DutchPostCodeColumn`.

```kotlin
generator.configureColumnTypeMapping()
   .setColumnTypeForName(
        table = "EMPLOYEE_ADDRESS",
        column = "KIND",
        columnType = AddressTypeAsStringColumn::class.java)
```
The `AddressTypeAsStringColumn` is a custom specialization of `EnumAsStringColumn<AddressType>`, which only needs to override the `toEnum` and `nullable` method`:

```kotlin
class AddressTypeAsStringColumn(table: Table, name: String) : EnumAsStringColumn<AddressType>(table, name, AddressType::class.java) {
    override val nullable = NullableAddressTypeAsStringColumn(table, name)
    override fun toEnum(name: String): AddressType = AddressType.valueOf(name)
}
```

=== Setting sequence names
Many vendors support sequences for generating primary keys, but the information schema does not store which sequence is used for which table. So, unfortunately, you have to manually configure this, as follows:
```kotlin
 generator.configurePrimaryKeySequences()
            .setSequenceNameForPrimaryKey("core", "employee", "id", "EMPLOYEE_SEQ")
```
This is fine if you have a small schema, but cumbersome if you have > 100 tables to configure. If you have a consistent naming scheme, you can write your own implementation of `SequenceForPrimaryKeyResolver`
```kotlin
generator.mappingConfigurer()
 .sequenceForPrimaryKeyResolver(AcmeSequenceMapper)

  object AcmeSequenceMapper : SequenceForPrimaryKeyMapper {
        override fun invoke(properties: ColumnMappingProperties): String? =
            if (properties.isPrimaryKey) properties.table.value + "_SEQ" else null
    }
```
==== Output configuration
Whew, that was a lot of information. Don't worry, you're almost done. Now the `CodeGenerator` has everything it needs to produce the right metadata objects. You only need to tell it where to put it.

This example points to `src/generated-sources/kotlin` in your project root and creates a package tree `com.dbobjekts.testdb.acme` under it.
In this package will be a `CatalogDefinition.kt` kotlin object with subpackages for each schema, which contain one `Schema` object and a `Table` object for each table in the schema.
```kotlin
generator.configureOutput()
            .basePackageForSources("com.dbobjekts.testdb.acme")
            .outputDirectoryForGeneratedSources(Paths.get("src/generated-sources/kotlin").toAbsolutePath().toString())
```

==== Validate and produce your code
Now you're set to produce your code, like so.
```kotlin
generator.generateSourceFiles()
```
If all is well, you now have a bunch of files and packages under the designated source folder, ready to be used for querying.

However, after you have done your first code generation run, it's advisable to add some validation to ensure there are not unexpected changes in the database schema. So, we want to do a dry-run of the generated code and compare the output to the current state of the metadata. If there are no differences there is no point to overwrite the generated source files. And if there _are_ differences you probably want to inspect them first. Here's how you create the diff we need.
```kotlin
val diff: List<String> = generator.differencesWithCatalog(CatalogDefinition)
assertThat(diff).describedAs("acme catalog differs from database definition").isEmpty()
```
`differencesWithCatalog` takes the target `CatalogDefinition` that would normally be overwritten, and for each detected difference with the current status quo of the db structure, a line is added to the output. So, if the employee table suddenly has a non-null column `shoe_size` added to it, the test will fail with `DB column EMPLOYEE.SHOE_SIZE not found in catalog`.

Once aware of the changes, you can generate the catalog again and make appropriate changes to the application code, because now the `Employee` metadata object has an extra mandatory column and calls to `mandatoryColumns` will have compiler errors.

Or would you rather fix it in production?


== Querying
TBD

=== The TransactionManager and Transaction
TBD

=== Inserting data
Let's start with getting some data into the tables. The `insert(..)` method takes a (generated) `Table` implementation and returns a corresponding `*InsertBuilder` instance.
In the example below these would be `CountryInsertBuilder` and `EmployeeInsertBuilder`.

The insert builders contain setter methods for all columns. In addition it has a handy `mandatoryColumns(..)` shortcut (provided the table has at least one non-nullable column) to make sure you provide all the required values.

```kotlin
  transaction.insert(Country).mandatoryColumns("nl", "Netherlands").execute()
  val petesId: Long = transaction.insert(Employee).mandatoryColumns("Pete", 5020.34, LocalDate.of(1980, 5, 7)).married(true).execute()
```

- The `Country` object has two mandatory columns and no auto-generated key. The `execute()` method returns the value of the JDBC call `PreparedStatement.executeUpdate()`, which should be 1 for a successful insert.
- The `Employee` table has four mandatory columns. The optional `married` property is set in a setter method. The table has a generated primary key, which is returned by the `execute()` method.

=== Updating and deleting
Update statements have a similar syntax, so let's discuss them now before moving on the more elaborate select statements. The `update(..)` method also takes a table and returns a `*UpdateBuilder` object.

```kotlin
 transaction.update(Employee).salary(4500.30).married(null).where(e.id.eq(12345))
```

- There is no `mandatoryColumns()` method.
- You can provide a null to a setter method if the corresponding database column is nullable: `update(Employee).married(null)`.
- Note that you cannot do the same with `salary`, because that is non-nullable: `.salary(null)` will not compile
- A where-clause is optional. This will update all rows in the table, so watch out.
- You close the statement with an explicit `execute()`.

=== The where-clause in details
Update, select and delete are executed against a range of database rows that satisfy certain criteria. These criteria are expressed in the where-clause.
The possibilities for generated db-Objekts statements are not as flexible as what you can achieve in native SQL, but they are more convenient to use and still cover a lot of common scenarios.

The canonical form of the where clause is `statement.where(column .. operator .. [value, otherColumn] [and|or] ... )` which is quite analogous to normal SQL usage.

```kotlin
 where(Employee.name.eq("Janet"))
 where(Employee.dateOfBirth.gt(LocalDate.of(1980,1,1)))
```
These are the operators you can use.

- `eq`: is equal to
- `ne`: is not equal to.
- `gt`: is greater than.
- `lt`: is less than.
- `gte`: is greater than or equal.
- `lte`: is less than or equal.
- `within`: is within a range of values.
- `notIn`: is not within a range of values.
- `startsWith`: (for character type only)
- `endsWith`: (for character type only)
- `contains`:  (for character type only)
- `isNull`
- `isNotNull`

You can chain conditions using `and` or `or` and you can even build nested conditions:

```kotlin
  where(e.married.eq(true).or(e.name.eq("John").or(e.name).eq("Bob"))) // all married people, plus John and Bob
```

- If you have no conditions to constrain your selection you omit the where clause in SQL. In db-Objekts you have to close the select/update/delete statement with `noWhereClause()`. Be very careful, especially with deleting!

=== Basic select statements
Let's move on to Select statements now. The pattern is `transaction.select( col1, col2, ... ).where( conditions ).[first()|asList()]`. You start with listing the columns you want to retrieve, the whereclause (or `noWhereClause`) and then retrieve a list of results

This query selects name and salary for all rows in the employee table. Notice we have imported the 'e' alias from the Aliases object. This is a handy shortcut that refers to the exact same Employee object.
```kotlin
 val asList: List<Pair<Long, String>> = it.select(e.id, e.name).noWhereClause().asList() // potentially empty
 val asOption: Pair<Long, String>? = it.select(e.id, e.name).noWhereClause().firstOrNull() // None if no row can be retrieved
 val singleResult: Pair<Long, String> = it.select(e.id, e.name).noWhereClause().first() //Will throw an exception if no row can be found
```

The result is always a Tuple object that corresponds in size and type to the colummns you specified in the `.select(..)` call. For null-safety's sake all values are returned as nullable types, because primitive instances (Int, Long, Boolean etc.) cannot be null in Kotlin, but *can* be null in the database.

The power of relational databases lies in combining results from multiple tables by laying the proper join conditions. The `Employee` and `Address` tables are linked via the `EmployeeAddress` table in a many-to-many fashion. Since the foreign key relations are explicit in the source code, db-Objekts can build the joins for you:

```kotlin
  transaction.select(e.name, e.dateOfBirth, e.children, e.married).where(Address.street.eq("Pete Street")).asList()
```

We can select from the `Employee` table with a constraint on the `Address` table, without specifying the join! This mechanism saves you a lot of typing, but comes with limitations:
1) There must be an explicit foreign-key relationship between the tables used in your statement, or a join table that links two tables referred in your query, like in the above example.
2) all joins are left outer joins.

If the framework cannot unambiguously resolve the join conditions, you have to provide them yourself. Call the `from(SomeTable)` method with the driving table of your selection, and add the tables to joined as follows:

```kotlin
 transaction.select(e.name, c.name)
      .from(Employee.innerJoin(ea).innerJoin(Address).innerJoin(Country))
      .where(ea.kind eq "WORK").asList()
```

This resolves to the following SQL:

```sql
 FROM EMPLOYEE e JOIN EMPLOYEE_ADDRESS ae on e.id = ae.employee_id JOIN ADDRESS a on a.id = ae.address_id join COUNTRY c on c.id = a.country_id
```

`asList` always return a (potentially empty) list of results. If one row is all you need, you can invoke `first()` or the safer option `firstOrNull()`, since the former will throw if the resultset was empty.

When you execute a select statement, db-Objekts pulls all results into a list structure, which add to the JVM heap. This may not be what you want.
The `forEachRow()` call lets you inspect the resultset row by row through a custom predicate so you can decide how to handle them and even abort further retrieval, which means reduced traffic from the RDBMS to your application.
```kotlin
  val buffer = mutableListOf<String?>()
    transaction.select(e.name).noWhereClause().orderAsc(e.name).forEachRow({ row ->
    buffer.add(row)
    //there are three rows in the resultset, but we stop fetching after two
    buffer.size != 2
})
```

You can further tweak select results with the `orderBy` and `limit(..)` methods. This orders all employees by salary (highest first), then by name (A-Z), and retrieves the first ten rows.
Note that these constraints are executed server-side, as they are part of the SQL. db-Objekts takes care of the proper syntax, because vendors handle the limit clause differently.

```kotlin
  tr.select(e.name).noWhereClause.orderDesc(e.salary).orderAsc(e.name).limit(10).asList()
```

=== Outer joins and more customization
TBD

=== Custom sql queries
TBD

== Advanced topics
TBD

=== Customizing the code generation
TBD

=== Creating custom column types
TBD

== Status and roadmap
db-Objekts has been a long time in the making. I started it in Scala, but switched to Kotlin because its null-safety is perfectly suited to the world of (relational) data. For several years it remained a hobby project and was not mature enough to become the Open Source tool I had in mind. But that time has now come.

This is the very first alpha release. The API may change slightly, so it is not yet ready for a beta release and you should not use it in production yet. While I'm confident and proud of my work, more rigorous testing is needed.

=== Roadmap

* From Januari 2023 a number of alpha releases will cover the following
**  Close to 100% unit test coverage
** Full coverage for all column types in the H2 database, used for testing
** Improving and cleaning up source code documentation and user docs
** Minor alterations the API with regard to method names and possible refactoring of packages

* The beta release planned for spring 2023 will cover:
** Addition of PostgreSQL and MySQL as vendor types
** Rigorous integration tests on dockerized images of all database vendors as part of the build
** No more API changes are to be expected.
