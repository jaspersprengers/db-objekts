:toc:

= Introduction
:imagesdir: ./docs

NOTE: db-Objekts is currently in alpha. The API is still subject to change and is not production ready. During the alpha release it will only support MariaDB. A beta is planned for early 2023 followed by a first official release later that year. This release will support MySQL, PostgreSQL and Oracle. See xref:_status_and_roadmap[for the planning]

== Fluent, type-safe, lightweight and opinionated
db-Objekts is a Kotlin library to perform queries on a relational databases in application code.
It generates source code that acts as metadata for all tables, columns and foreign keys. You then use these stateless Kotlin objects to build type-safe and fluent queries, comfortably using
your IDE's autocomplete, while db-Objekts takes care of the SQL boilerplate and type conversions.

The project was conceived and built by me, Jasper Sprengers, a software developer living in the Netherlands.

db-Objekts has conceptual similarities to object relational mapping (ORM) frameworks like Hibernate, but is also quite different. ORMs work with stateful entities that abstract away the database layer, even the individual tables. They are not lightweight or easy to master well. db-Objekts is focused on executing queries on tables, but these tables have become part of your application's source code. This gives you all the benefits of your IDE's auto-complete features, in addition to Kotlin's type and null-safety.

Let's start with an overview of features.

== A bird's eye feature view
The following demo showcases what you can achieve with db-Objekts (https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/AcmeCatalogCodeGenComponentTest.kt[full source code]).

We have a simple database of a lending library with five tables

* `author` represents a person, with name, bio, and data of birth.
* `book` has the official isbn as its primary key, a title, year of publication and a reference to its author.
* `item` represents a physical copy of a book. It refers to the `book` table and stores the date of acquisition. There can be zero or more copies of a book title.
* `member` only stores the name of an invdividual member
* `loan` keeps a record of all the books (items) taken out by a member. It refers to `item` and `member` and keeps the date taken out and returned.

image::datamodel.png[datamodel,600]

First, generate metadata objects for our database. `CodeGenerator` takes care of that.
```kotlin
val generator = CodeGenerator()
       .withDataSource(datasource = H2DB.dataSource)
generator.outputConfigurer()
        .basePackageForSources("com.acme.dbobjekts")
        .outputDirectoryForGeneratedSources(Paths.get("src/gen/kotlin")
            .toAbsolutePath().toString())
generator.generateSourceFiles()
```

This is a bare-bones setup. There is much more to fine-tune. This writes metadata objects under the package `com.acme.dbobjekts` in a `gen` source folder (to indicate you should not alter them manually).

For each table you now have a corresponding `Table` implementation, i.e. `Book`, `Author`, `Loan`, etc. Each contains fields corresponding to the columns in the table, and we'll use them to build type-safe queries. In simplified form:
```kotlin
object Author : Table("AUTHOR") {
    //primary keys for this table are generated by using a sequence
    val id = com.dbobjekts.metadata.column.SequenceKeyLongColumn(this, "ID", "AUTHOR_SEQ")
    val name = com.dbobjekts.metadata.column.VarcharColumn(this, "NAME")
    //notice that bio can be null, while name cannot, so they have different Column implementations
    val bio = com.dbobjekts.metadata.column.NullableVarcharColumn(this, "BIO")
}
```

But first we need to get a `TransactionManager`. This wraps a `javax.sql.DataSource` and acts as a factory for transactions. You typically only need one instance per database. This example is for an embedded H2 database, taken from the project `com.db-Objekts.sampledbs.h2.H2DB`.

The code generation stage produced a `CatalogDefinition` Kotlin object. The TransactionManager needs this to produce SQL boilerplate specific to our schemas.

```kotlin
val dataSource = HikariDataSourceFactory.create(url = "jdbc:h2:mem:test",
    username = "sa",
    password = null,
    driver = "org.h2.Driver")
val transactionManager = TransactionManager.builder()
    .withCatalog(CatalogDefinition)
    .withDataSource(dataSource).build()
```

To get a connection from the TransactionManager and start performing queries, use the following syntax (we'll use `tm` for TransactionManager instances and `tr` for Transaction throughout this tutorial)
```kotlin
val resultOfQuery = tm.newTransaction { tr->
    //execute your query/queries here
}
```
The `newTransaction()` method's signature is `fun <T> newTransaction(function: (Transaction) -> T): T`. You provide it with a lambda that takes a `Transaction` and can produce any result. The `invoke()` operator does the same, so you can express it even more concisely:
```kotlin
val books: List<String> = tm { it.select(Book.isbn).asList() }
```

That was our very first query: select the ISBN column from the `book` table and return it as a `List<String`. Now let's add an author, title and member.

The `mandatoryColumns(..)` call is a convenience method to make sure you don't miss any of the non-null columns in your insert.
When the table in question has an auto-generated id, it is returned as a `Long`. We need to store it to be used as a foreign key later.

```kotlin
val orwell: Long = tr.insert(Author)
    .mandatoryColumns("George Orwell").execute()

// the primary key of the book table is not auto-generated. In this case execute() returns 1.
tr.insert(Book)
    .mandatoryColumns("ISBN-1984", "Nineteen-eighty Four", orwell, LocalDate.of(1948,1,1))
    .execute()

val john = tr.insert(Member).mandatoryColumns("John").execute()
```

We forgot to put a bio for George Orwell. Let's do that now. Notice the use of the where clause. Common sql operator symbols (=,<,>,!=) have textual counterparts `eq`, `lt`, `ne` etc,

And/Or conditions and even embedded conditions are possible. More on that later.
```kotlin
  tr.update(Author)
      .bio("(1903-1950) Pseudonym of Eric Blair. Influential writer of novels, essays and journalism.")
      .where(Author.id.eq(orwell))
```
Notice the power of autocomplete . You instantly know which columns are available, which types they take, and whether null values are allowed.

image::autocomplete_update.png[autocomplete_update, 600]

image::autocomplete_insert.png[autocomplete_insert, 600]

Add a physical copy, and then we have enough data to create a loan record.
```kotlin
val copy1984 = tr.insert(Item)
    .mandatoryColumns("ISBN-1984", LocalDate.of(1990,5,5))
    .execute()
//John takes out the copy of 1984 which was acquired in 1990
tr.insert(Loan).mandatoryColumns(memberId = john,
    itemId = copy1984copy1984,
    dateLoaned = LocalDate.now()).execute()
```

Now we can start selections. Let's get a list of all titles and their author data. This is what a select query in db-Objekts looks like.
```kotlin
val bookAuthors: List<Tuple3<String, String, String?>> =
    tr.select(Book.title, Author.name, Author.bio).asList()
```
Notice there is no `from` clause, because table references are present in the columns that you provide in the call to `select(..`) and db-Objekts can figure out the necessary joins. The terminating `asList()` call returns a list of type-safe tuples that correspond exactly to the number and types of the columns in the `select(..)` call. Notice that `Author.bio` is a nullable column. Hence, the corresponding value in the tuple is `String?`, not `String`.

Let's take it up a notch! This query involves all five tables and returns `List<Tuple5<LocalDate, Long, String, String, String>>`. Since all `Tuple*` classes are data classes, you can deconstruct them into a more readable output

```kotlin
// the type returned is List<Tuple5<LocalDate, Long, String, String, String>>
tr.select(Loan.dateLoaned, Item.id, Book.title, Author.name, Member.name).asList()
  .forEach { (dateLoaned, item, book, author, member) ->
    println("Item $item of $book by $author loaned to $member on $dateLoaned")
    //"Item 1 of Nineteen-eighty Four by George Orwell loaned to John on 2022-12-23"
  }

```
This concludes our bird's eye view of db-Objekts. Check out `LibraryComponentTest` to get you going.

There is much, much more to explore in the following sections, so let's dig in!

== Getting started


=== Installation and configuration
You can get the latest release from https://mvnrepository.com/search?q=com.db-objekts[Maven central]

The main jar is `com.db-objekts:db-objekts-core`, but you also need a vendor-specific implementation, which includes the core jar. Include it in you maven or gradle build:
```xml
<dependency>
	<groupId>com.db-objekts</groupId>
	<artifactId>db-objekts-mariadb</artifactId>
	<version>...</version>
</dependency>
```

`DataSource` and  an appropriate JDBC driver are not inherited from db-objekts, as these should be already on the classpath.

All you need in a SpringBoot context is to create a Bean for your `TransactionManager` (provided the DataSource is already configured):
```kotlin
// Call the method something other than transactionManager(), or it will clash with the one in org.springframework.transaction
@Bean()
fun dbObjektsTransactionManager(dataSource: DataSource): TransactionManager {
    return TransactionManager.builder()
        .withDataSource(dataSource)
        .withCatalog(CatalogDefinition)
        .build()
}
```

Now you can inject the `TransactionManager` and you're ready to query. Note: this examples assumes you have already generated the metadata objects (`Employee` in this case), which we'll cover in the next section.
```kotlin
@Service
class DataService(val transactionManager: TransactionManager) {

    fun getEmployeeNames(): List<String> {
        return transactionManager {
            it.select(Employee.name).asList()
        }
    }
}
```

=== Generating metadata objects
Before we dive into the details of code generation, some clarification is in order.

Auto-generating code is an established practice, ever since WSDL. For example, you can create richly annotated interfaces from an `openapi.yaml` file that specify the available REST endpoints and expected messages. By implementing these interfaces you create a compile-time dependency on the generated code.

db-Objekts is similar in that the generated metadata objects which represent the tables and columns become tightly coupled to your source code. That is a good thing, because the database _is_ already an integral part of the application logic, also if you interact through native SQL. The drawback of that approach is that structural changes to the schemas will go unnoticed unless you have extensive integration tests (unit tests won't catch it). Otherwise, defect pop up only in production. Not good!

When a component implements a service, it often owns the specification (or rather the team does). Such files belong to the source repository and since _you_ manage them, it's fine to re-generate the code whenever you do a fresh buil (during the generate-sources phase, which takes place before compilation).

A database creation script is similar in purpose to an openapi.yaml file. However, the important difference is one of ownership: your project may not own the database structure. Even if you have a copy of the dump in source control and can create a containerized version of it, it matters a great deal whether that dump file is the source of truth. If not, unannounced changes may mess up the status quo. We need more validation.

==== Code generation and validation during the SDLC
Generating code is harmless when you're starting out with db-Objekts, since there's no source code yet that uses the new metadata. But later, it makes sense to compare the current db structure to the generated metadata, before overwriting anything. So please stick to the following best practices:

* Always write generated code to a separate source folder, called `gen` or `generated-sources`. Never manually alter this code. All the tweaks you should need are explained in the next sections, and we gladly consider feature requests :-)
* Put the generated kotlin sources under version control, yes, even though they are generated. Remember, the state of the database may not be in your hands.
* Include a regular automated test to validate the database against the generated sources. Validation should take place in the test phase, not the generate-sources phase. See https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-mariadb/src/test/kotlin/com.dbobjekts.mariadb/MariaDBIntegrationTest.kt[MariaDBIntegrationTest] for an example.

=== Code generation in detail
With this in mind, let's have a detailed look at the process. https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/codegen/CodeGenerator.kt[CodeGenerator] is our port of call for the entire process and you can check out https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/AcmeCatalogCodeGenComponentTest.kt[AcmeCatalogCodeGenComponentTest] for a comprehensive example.
Configuration is grouped into the following sections:

* The mandatory javax.sql.DataSource.
* Configuration for exclusions.
* Configuration for mapping column types to SQL types, using custom type for certain columns
* Configuration for setting the sequence names for auto-generated keys.
* Configuration of the output

==== First steps
We're making the code generation part of the standard test phase and include a component test for it.
```kotlin
class CodeGenerationAndValidationTest {
    @Test
    fun validate(){
       val generator = CodeGenerator()
    }
}
```
First you need to set up the `DataSource`. Make sure the user has sufficient privileges to read the relevant metadata tables (INFORMATION_SCHEMA in MySQL/MariaDB)
```kotlin
   val generator = CodeGenerator().withDataSource(myDataSource)
```
==== Configuring exlusions of tables and columns
Sometimes the database has columns, tables, or even entire schemas that are not relevant to the application's business logic. A typical example are read-only audit columns that are populated by triggers.

We don't want these in the generated code, and here's how you do that:
```kotlin
generator.configureExclusions()
      //any column with the string 'audit' in it, in any table or schema
     .ignoreColumnPattern("audit")
     //all 'date_created' columns in any table or schema
     .ignoreColumn("date_created")
     //skip the entire finance schema
     .ignoreSchemas("finance")
     //ignore the table country, but only in the hr schema
     .ignoreTable("country", schema = "hr")
```

NOTE: System schemas per vendor like `sys`, `mysql` or `information_schema` are already ignored. No need to exclude them explicitly.

==== Configuring column mapping
db-Objekts chooses a suitable implementation of https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/metadata/column/Column.kt[Column], depending on the db type (e.g. `CHAR(10)` or `INT(6)`). Sometimes you want to fine-tune this mapping. For example: in  MySQL the type `TINYINT(1)` is mapped to a `Byte` by default, but as it is often used as a boolean value (with 1 or 0), it's more convenient to map it to Boolean.

db-Objekts iterates through a list of https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/codegen/datatypemapper/ColumnTypeMapper.kt[ColumnTypeMapper] instances, which is a functional interface that receives all the metadata you need for a given column in a  https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/main/kotlin/com/dbobjekts/codegen/datatypemapper/ColumnMappingProperties.kt[ColumnMappingProperties] object in order for the implementation to return an appropriate `Column`, or null if the mapper does not apply. db-Objekts tries you custom mappings in order of registration to find a match, and then defaults to the vendor specific mapping, which has a mapping for every SQL type in the database, like https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-mariadb/src/main/kotlin/com.dbobjekts.vendors.mariadb/MariaDBDataTypeMapper.kt[MariaDBDataTypeMapper]

Let's look at the options.

==== Overriding a column by sql type
As mentioned above, here's how you override the default mapping of `TINYINT` to a numeric type and instead use Boolean.

The convenience method `setColumnTypeForJDBCType` takes the SQL type and the class of the appropriate Column. `com.dbobjekts.metadata.columnNumberAsBoolean` takes care of converting an Int to Boolean and back.
```kotlin
generator.configureColumnTypeMapping()
   .setColumnTypeForJDBCType("TINYINT(1)", NumberAsBooleanColumn::class.java)
```

==== Overriding a column by name or pattern
db-Objekts lets you write you own Column implementations. This can be useful to:

* Use a business enum instead of an integer or character value, e.g. the `AddressTypeAsStringColumn` which maps to the `AddressType` enum
* Add extra validation or formatting to a column, e.g. a `DutchPostCodeColumn`.
* Cover up poor database design decision, for example a CHAR column which is abused as a Boolean with Ja/Nein.

See the xref:_creating_custom_column_types[advanced section] for details.

```kotlin
generator.configureColumnTypeMapping()
   .setColumnTypeForName(
        table = "EMPLOYEE_ADDRESS",
        column = "KIND",
        columnType = AddressTypeAsStringColumn::class.java)
```
The `AddressTypeAsStringColumn` is a custom specialization of `EnumAsStringColumn<AddressType>`.

=== Setting sequence names
Many vendors support sequences for generating primary keys, but the information schema does not store which sequence is used for which table. So, unfortunately, you have to manually configure this, as follows:
```kotlin
 generator.configurePrimaryKeySequences()
            .setSequenceNameForPrimaryKey("core", "employee", "id", "EMPLOYEE_SEQ")
```
This is fine if you have a small schema, but cumbersome if you have > 100 tables to configure. If you have a consistent naming scheme, you can write your own implementation of `SequenceForPrimaryKeyResolver`
```kotlin
generator.mappingConfigurer()
 .sequenceForPrimaryKeyResolver(AcmeSequenceMapper)

  object AcmeSequenceMapper : SequenceForPrimaryKeyMapper {
        //every column offered is already a primary key. No need to check for it yourself
        override fun invoke(properties: ColumnMappingProperties): String? =
            properties.table.value + "_SEQ"
    }
```
==== Output configuration
Whew, that was a lot of information. Don't worry, you're almost done. Now the `CodeGenerator` has everything it needs to produce the right metadata objects. You only need to tell it where to put it.

This example points to `src/generated-sources/kotlin` in your project root and creates a package tree `com.dbobjekts.testdb.acme` under it.
In this package will be a `CatalogDefinition.kt` kotlin object with subpackages for each schema, which contain one `Schema` object and a `Table` object for each table in the schema.
```kotlin
generator.configureOutput()
            .basePackageForSources("com.dbobjekts.testdb.acme")
            .outputDirectoryForGeneratedSources(Paths.get("src/generated-sources/kotlin").toAbsolutePath().toString())
```

==== Validate and produce your code
Now you're set to produce your code, like so.
```kotlin
generator.generateSourceFiles()
```
If all is well, you now have a bunch of files and packages under the designated source folder, ready to be used for querying.

However, after you have done your first code generation run, it's advisable to add some validation to ensure there are not unexpected changes in the database schema. So, we want to do a dry-run of the generated code and compare the output to the current state of the metadata. If there are no differences there is no point to overwrite the generated source files. And if there _are_ differences you probably want to inspect them first. Here's how you create the diff we need.
```kotlin
val diff: List<String> = generator.differencesWithCatalog(CatalogDefinition)
assertThat(diff).describedAs("acme catalog differs from database definition").isEmpty()
```
`differencesWithCatalog` takes the target `CatalogDefinition` that would normally be overwritten, and for each detected difference with the current status quo of the db structure, a line is added to the output. So, if the employee table suddenly has a non-null column `shoe_size` added to it, the test will fail with `DB column EMPLOYEE.SHOE_SIZE not found in catalog`.

Once aware of the changes, you can generate the catalog again and make appropriate changes to the application code, because now the `Employee` metadata object has an extra mandatory column and calls to `mandatoryColumns` will have compiler errors.

Or would you rather fix it in production?


== Querying
The next section will be all about writing queries. For that, you need a reference to a `TransactionManager`.

=== The TransactionManager and Transaction
TBD

=== Inserting data
Let's start with getting some data into the tables. The `insert(..)` method takes a `Table` implementation and returns a corresponding `*InsertBuilder` instance.

In the example below these would be `CountryInsertBuilder` and `EmployeeInsertBuilder`.

The insert builders contain setter methods for all columns. In addition it has a handy `mandatoryColumns(..)` shortcut (provided the table has at least one non-nullable column) to make sure you provide all the required values.

```kotlin
  transaction.insert(Country).mandatoryColumns("nl", "Netherlands").execute()
  val petesId: Long = transaction.insert(Employee)
      .mandatoryColumns("Pete", 5020.34, LocalDate.of(1980, 5, 7))
      .married(true)
      .execute()
```

- The `Country` object has two mandatory columns and no auto-generated key. The `execute()` method returns the value of the JDBC call `PreparedStatement.executeUpdate()`, which should be 1 for a successful insert.
- The `Employee` table has four mandatory columns. The optional `married` property is set in a setter method. The table has a generated primary key, which is returned by the `execute()` method.

=== Updating and deleting
Update statements have a similar syntax, so let's discuss them now before moving on the more elaborate select statements. The `update(..)` method also takes a table and returns a `*UpdateBuilder` object.

```kotlin
 transaction.update(Employee)
     .salary(4500.30)
     .married(null)
     .where(e.id.eq(12345))
```

- There is no `mandatoryColumns()` method.
- You can provide a null to a setter method if the corresponding database column is nullable: `update(Employee).married(null)`.
- Note that you cannot do the same with `salary`, because that is non-nullable: `.salary(null)` will not compile
- You close the statement with an explicit `execute()`.

=== The where-clause in details
Update, select and delete are executed against a range of database rows that satisfy certain criteria. These criteria are expressed in the where-clause.

The possibilities for generated db-Objekts statements are not as flexible as what you can achieve in native SQL, but they are more convenient to use and still cover a lot of common scenarios.

The canonical form of the where clause is `statement.where(column .. operator .. [value, otherColumn] [and|or] ... )` which is quite analogous to normal SQL usage.

```kotlin
 where(Employee.name.eq("Janet"))
 where(Employee.dateOfBirth.gt(LocalDate.of(1980,1,1)))
```
These are the operators you can use.

- `eq`: is equal to
- `ne`: is not equal to.
- `gt`: is greater than.
- `lt`: is less than.
- `gte`: is greater than or equal.
- `lte`: is less than or equal.
- `within`: is within a range of values.
- `notIn`: is not within a range of values.
- `startsWith`: (for character type only)
- `endsWith`: (for character type only)
- `contains`:  (for character type only)
- `isNull`
- `isNotNull`

You can chain conditions using `and` or `or` and you can even build nested conditions:

```kotlin
  where(e.married.eq(true).or(e.name.eq("John").or(e.name).eq("Bob"))) // all married people, plus John and Bob
```

If you have no conditions to constrain your selection you can omit the where clause in a SQL statement. In db-Objekts that is not possible, but for update and delete statements there is a no-arg `where()` overload that achieves the same thing. This is needed to finish and execute the statement. For select statements, a whereclause is optional, since there's no damage done if you omit it by mistake.

=== Basic select statements
Let's move on to select statements now. The pattern is `transaction.select( col1, col2, ... ).where( conditions ).[first[orNull]()|asList()]`. You start with listing the columns you want to retrieve, the whereclause and then retrieve a list of results

This query selects name and salary for all rows in the employee table. Notice we have imported the 'e' alias from the Aliases object. This is a handy shortcut that refers to the exact same Employee object.
```kotlin
 val asList: List<<Long, String>> = it.select(e.id, e.name).noWhereClause().asList() // potentially empty
 val asOption: Tuple2<Long, String>? = it.select(e.id, e.name).noWhereClause().firstOrNull() // None if no row can be retrieved
 val singleResult: Tuple2<Long, String> = it.select(e.id, e.name).noWhereClause().first() //Will throw an exception if no row can be found
```

The result is always a Tuple* object that corresponds in size and type to the colummns you specified in the `.select(..)` call.

The power of relational databases lies in combining results from multiple tables by laying the proper join conditions. The `Employee` and `Address` tables are linked via the `EmployeeAddress` table in a many-to-many fashion. Since the foreign key relations are explicit in the source code, db-Objekts can build the joins for you:

```kotlin
  transaction.select(e.name, e.dateOfBirth, e.children, e.married).where(Address.street.eq("Pete Street")).asList()
```

We can select from the `Employee` table with a constraint on the `Address` table, without specifying the join! This mechanism saves you a lot of typing, but comes with limitations:

* There must be an explicit foreign-key relationship between the tables used in your statement, or a join table that links two tables referred in your query, like in the above example.
* By default, the joins are inner joins. Using outer joins is possible, but comes with some caveats, so it has a xref:_outer_joins_and_more_customization[dedicated section].

If the framework cannot unambiguously resolve the join conditions, you have to provide them yourself. Call the `from(SomeTable)` method with the driving table of your selection, and add the tables to joined as follows:

```kotlin
 transaction.select(e.name, c.name)
      .from(Employee.innerJoin(ea).innerJoin(Address).innerJoin(Country))
      .where(ea.kind eq "WORK").asList()
```

This resolves to the following SQL:

```sql
 FROM EMPLOYEE e JOIN EMPLOYEE_ADDRESS ae on e.id = ae.employee_id JOIN ADDRESS a on a.id = ae.address_id join COUNTRY c on c.id = a.country_id
```

`asList` always return a (potentially empty) list of results. If one row is all you need, you can invoke `first()` or the safer option `firstOrNull()`, since the former will throw if the resultset was empty.

When you execute a select statement, db-Objekts pulls all results into a list structure, which add to the JVM heap. This may not be what you want.
The `forEachRow()` call lets you inspect the resultset row by row through a custom predicate so you can decide how to handle them and even abort further retrieval, which means reduced traffic from the RDBMS to your application.
```kotlin
  val buffer = mutableListOf<String?>()
    transaction.select(e.name).noWhereClause().orderAsc(e.name).forEachRow({ row ->
    buffer.add(row)
    //there are three rows in the resultset, but we stop fetching after two
    buffer.size != 2
})
```

You can further tweak select results with the `orderBy` and `limit(..)` methods. This orders all employees by salary (highest first), then by name (A-Z), and retrieves the first ten rows.
Note that these constraints are executed server-side, as they are part of the SQL. db-Objekts takes care of the proper syntax, because vendors handle the limit clause differently.

```kotlin
  tr.select(e.name).noWhereClause.orderDesc(e.salary).orderAsc(e.name).limit(10).asList()
```

=== Outer joins and more customization
Recall the previous query `tm.select(Employee.name, Hobby.name)`, which does an inner join and only returns results where a `hobby` record is linked to an `employee`. If we want all employee records, what we need is a left outer join. There are two basic options.
```
tr.select(Employee.name, Hobby.name).useOuterJoins()
tr.select(Employee.name, Hobby.name).from(Employee.leftJoin(Hobby))
```
The method `useOuterJoins` is an instruction to use left outer joins for every table involved. The other option is to build the join chain yourself, which gives you greater control when there are more tables involved. Maybe not everything should be an outer join.

But the above code will run into trouble! Do you see it? `Hobby.name` is an instance of a non-nullable `VarcharColumn`, which demands a `String` data type, but when there are no matches, it gets a null back from the database and slaps you with a RuntimeException, because the query wants to return `Tuple2<String,String?>`. Ouch.

Not to worry. Again, there are two options at hand. The first is to use the nullable counterpart for the columns that can be null. Notice the use of `Hobby.name.nullable`. Each non-nullable column implementation has such a value, and it's there for exactly this purpose. Now the return type of the query will be `Tuple2<String,String?>`.
```kotlin
tr.select(Employee.name, Hobby.name.nullable).useOuterJoins()
```
A more sweeping solution is to stick to the standard parameterized return type and use default values instead of nulls, e.g. the empty string for character columns and zero for anything numeric.
The following verbose method handles that.
```
tr.select(Employee.name, Hobby.name).useOuterJoinsWithDefaultValues()
```
Now whenever a null is encountered for a Column that cannot be null, a default value is used.

Remember though that the `Hobby.name.nullable` strategy is nearly always preferable. NULL values in a database are potentially significant, especially in numeric values. If number of children is zero, you don't have any. If it is null, we don't know. The two are not equal, and `useOuterJoinsWithDefaultValues()` ignores these differences.

=== Custom sql queries
db-Objekts is not out to kill SQL. There are many cases where the select, insert, update and delete queries fall short of your wishes. That is a deliberate design decision. db-Objekts aims to make mundane queries a joy, and not over-complicate its API.

But you can still execute native free-form SQL through the TransactionManager and enjoy the same benefits of type-safe results. There are two flavors: queries that return results and those that don't. Let's tackle the latter first.

```kotlin
 tr.execute("CREATE SCHEMA if not exists core")
```
`Transaction.execute` takes a String of SQL and a vararg of arbitrary parameters. The length must match the number of `?` placeholders in the query.
```kotlin
 tr.execute("update core.employee where e.name=?", "john")
```
That was too easy. Let's move up to statements that retrieve results.

Take the example from https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/test/kotlin/com/dbobjekts/component/CustomSQLComponentTest.kt[CustomSQLComponentTest]
```kotlin
val (id, name, salary, married, children, hobby) =
    it.sql(
        "select e.id,e.name,e.salary,e.married, e.children, h.NAME from core.employee e join hr.HOBBY h on h.ID = e.HOBBY_ID where e.name = ?",
        "John"
    ).withResultTypes().long().string().double().booleanNil().intNil().stringNil()
        .first()
```

The `sql` method on `Transaction` works the same as regular select statements when it comes to retrieving parameterized tuples. But instead of providing that information through a list of Columns, you do it in a call to `withResultTypes`.

This returns a builder with methods for each available standard SQL type in a nullable and non-nullable flavour. String together all the methods you need, call `first()`, or `asList()`, and the output of the custom query will be returned in a type-safe tuple.

image::custom_sql.png[autocomplete_update, 600]

== Advanced topics

=== The db-Objekts metadata model
db-Objekts creates three main types  of metadata that correspond to the database schema:

* A single `CatalogDefinition` object with reference to one or more Schemas and a specification of the vendor type.
* A `Schema` object for each schema in the Catalog.
* One or more `Table` objects for each table in the schema.

Starting with https://github.com/jaspersprengers/db-objekts/blob/main/db-objekts-core/src/generated-sources/kotlin/com/dbobjekts/testdb/acme/CatalogDefinition.kt[CatalogDefinition]:

```kotlin
object CatalogDefinition : Catalog("H2", listOf(Core, Hr, Library))
```

the Library schema
```kotlin
object Library : Schema("LIBRARY", listOf(Author, Book, Item, Loan, Member))
```
and the `Book` table (omitting the stuff that's only for internal use)
```kotlin
object Book:Table("BOOK"){
    val isbn = com.dbobjekts.metadata.column.VarcharColumn(this, "ISBN")
    val title = com.dbobjekts.metadata.column.VarcharColumn(this, "TITLE")
    val authorId = com.dbobjekts.metadata.column.ForeignKeyLongColumn(this, "AUTHOR_ID", Author.id)
    val published = com.dbobjekts.metadata.column.DateColumn(this, "PUBLISHED")
}
```
All that is needed to create queries is expressed in the column types: how to create primary keys (auto generated, with a sequence, or manually), whether a type is nullable, and the parent table/column for primary keys.

=== Creating custom column types
TBD

== Status and roadmap
db-Objekts has been a long time in the making. I started it in Scala, but switched to Kotlin because its null-safety is perfectly suited to the world of (relational) data. For several years it remained a hobby project and was not mature enough to become the Open Source tool I had in mind. But that time has now come.

This is the very first alpha release. The API may change slightly, so it is not yet ready for a beta release and you should not use it in production yet. While I'm confident and proud of my work, more rigorous testing is needed.

=== Roadmap

* From Januari 2023 a number of alpha releases will cover the following
**  Close to 100% unit test coverage
** Full coverage for all column types in the H2 database, used for testing
** Improving and cleaning up source code documentation and user docs
** Minor alterations the API with regard to method names and possible refactoring of packages

* The beta release planned for spring 2023 will cover:
** Addition of PostgreSQL and MySQL as vendor types
** Rigorous integration tests on dockerized images of all database vendors as part of the build
** No more API changes are to be expected.
