package com.dbobjekts.metadata

import com.dbobjekts.AnyColumn
import com.dbobjekts.metadata.column.*
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.ZonedDateTime


object Columns {

    private val table = DefaultTable
    private const val DUMMY = "dummy"
    /**
     * @return either AutoKeyLongColumn or AutoKeyIntegerColumn
     */
    fun determineAutoGeneratedColumn(column: AnyColumn): AnyColumn =
        when (column) {
            is LongColumn -> AUTOKEY_LONG
            is IntegerColumn -> AUTOKEY_INTEGER
            else -> throw IllegalArgumentException("Only LongColumn or IntegerColumn expected.")
        }

    val VARCHAR = VarcharColumn(table, DUMMY)
    val VARCHAR_NIL = NullableVarcharColumn(table, DUMMY)

    val LONG = LongColumn(table, DUMMY)
    val LONG_NIL = NullableLongColumn(table, DUMMY)

    val INTEGER = IntegerColumn(table, DUMMY)
    val INTEGER_NIL = NullableIntegerColumn(table, DUMMY)

    val BYTE_ARRAY = ByteArrayColumn(table, DUMMY)
    val BYTE_ARRAY_NIL = NullableByteArrayColumn(table, DUMMY)

    val BLOB = BlobColumn(table, DUMMY)
    val BLOB_NIL = NullableBlobColumn(table, DUMMY)

    val CLOB = ClobColumn(table, DUMMY)
    val CLOB_NIL = NullableClobColumn(table, DUMMY)

    val BYTE = ByteColumn(table, DUMMY)
    val BYTE_NIL = NullableByteColumn(table, DUMMY)

    val BOOLEAN = BooleanColumn(table, DUMMY)
    val BOOLEAN_NIL = NullableBooleanColumn(table, DUMMY)

    val NUMBER_AS_BOOLEAN = NumberAsBooleanColumn(table, DUMMY)
    val NUMBER_AS_BOOLEAN_NIL = NullableNumberAsBooleanColumn(table, DUMMY)

    val DOUBLE = DoubleColumn(table, DUMMY)
    val DOUBLE_NIL = NullableDoubleColumn(table, DUMMY)

    val FLOAT = FloatColumn(table, DUMMY)
    val FLOAT_NIL = NullableFloatColumn(table, DUMMY)

    val BIGDECIMAL = BigDecimalColumn(table, DUMMY)
    val BIGDECIMAL_NIL = NullableBigDecimalColumn(table, DUMMY)

    val DATE = DateColumn(table, DUMMY)
    val DATE_NIL = NullableDateColumn(table, DUMMY)

    val DATETIME = DateTimeColumn(table, DUMMY)
    val DATETIME_NIL = NullableDateTimeColumn(table, DUMMY)

    val TIME = TimeColumn(table, DUMMY)
    val TIME_NIL = NullableTimeColumn(table, DUMMY)

    val TIMESTAMP = TimeStampColumn(table, DUMMY)
    val TIMESTAMP_NIL = NullableTimeStampColumn(table, DUMMY)

    val OFFSET_DATETIME = OffsetDateTimeColumn(table, DUMMY)
    val OFFSET_DATETIME_NIL = NullableOffsetDateTimeColumn(table, DUMMY)

    val AUTOKEY_LONG = AutoKeyLongColumn(table, DUMMY)
    val AUTOKEY_INTEGER = AutoKeyIntegerColumn(table, DUMMY)
    val SEQUENCE_LONG = SequenceKeyLongColumn(table, DUMMY, "")
    val SEQUENCE_INTEGER = SequenceKeyIntegerColumn(table, DUMMY, "")
    val FOREIGN_KEY_LONG = ForeignKeyLongColumn(table, DUMMY, LONG)
    val FOREIGN_KEY_LONG_NIL = OptionalForeignKeyLongColumn(table, DUMMY, LONG)
    val FOREIGN_KEY_INT = ForeignKeyIntColumn(table, DUMMY, INTEGER)
    val FOREIGN_KEY_INT_NIL = OptionalForeignKeyIntColumn(table, DUMMY, INTEGER)
    val FOREIGN_KEY_VARCHAR = ForeignKeyVarcharColumn(table, DUMMY, VARCHAR)
    val FOREIGN_KEY_VARCHAR_NIL = OptionalForeignKeyVarcharColumn(table, DUMMY, VARCHAR)

    fun varcharColumn(nullable: Boolean = false) = if (nullable) VARCHAR_NIL else VARCHAR
    fun longColumn(nullable: Boolean = false) = if (nullable) LONG_NIL else LONG
    fun integerColumn(nullable: Boolean = false) = if (nullable) INTEGER_NIL else INTEGER
    fun byteArrayColumn(nullable: Boolean = false) = if (nullable) BYTE_ARRAY_NIL else BYTE_ARRAY
    fun blobColumn(nullable: Boolean = false) = if (nullable) BLOB_NIL else BLOB
    fun clobColumn(nullable: Boolean = false) = if (nullable) CLOB_NIL else CLOB
    fun byteColumn(nullable: Boolean = false) = if (nullable) BYTE_NIL else BYTE
    fun booleanColumn(nullable: Boolean = false) = if (nullable) BOOLEAN_NIL else BOOLEAN
    fun numberAsBooleanColumn(nullable: Boolean = false) = if (nullable) NUMBER_AS_BOOLEAN_NIL else NUMBER_AS_BOOLEAN
    fun doubleColumn(nullable: Boolean = false) = if (nullable) DOUBLE_NIL else DOUBLE
    fun floatColumn(nullable: Boolean = false) = if (nullable) FLOAT_NIL else FLOAT
    fun bigDecimalColumn(nullable: Boolean = false) = if (nullable) BIGDECIMAL_NIL else BIGDECIMAL
    fun dateColumn(nullable: Boolean = false) = if (nullable) DATE_NIL else DATE
    fun dateTimeColumn(nullable: Boolean = false) = if (nullable) DATETIME_NIL else DATETIME
    fun timeColumn(nullable: Boolean = false) = if (nullable) TIME_NIL else TIME
    fun timeStampColumn(nullable: Boolean = false) = if (nullable) TIMESTAMP_NIL else TIMESTAMP
    fun offsetDateTimeColumn(nullable: Boolean = false) = if (nullable) OFFSET_DATETIME_NIL else OFFSET_DATETIME

    fun byName(columnType: ColumnType, nullable: Boolean = false): AnyColumn =
        when (columnType) {
            ColumnType.VARCHAR -> varcharColumn(nullable)
            ColumnType.LONG -> longColumn(nullable)
            ColumnType.INTEGER -> integerColumn(nullable)
            ColumnType.BYTE_ARRAY -> byteArrayColumn(nullable)
            ColumnType.BLOB -> blobColumn(nullable)
            ColumnType.CLOB -> clobColumn(nullable)
            ColumnType.BYTE -> byteColumn(nullable)
            ColumnType.BOOLEAN -> booleanColumn(nullable)
            ColumnType.NUMBER_AS_BOOLEAN -> numberAsBooleanColumn(nullable)
            ColumnType.DOUBLE -> doubleColumn(nullable)
            ColumnType.FLOAT -> floatColumn(nullable)
            ColumnType.BIGDECIMAL -> bigDecimalColumn(nullable)
            ColumnType.DATE -> dateColumn(nullable)
            ColumnType.DATETIME -> dateTimeColumn(nullable)
            ColumnType.TIME -> timeColumn(nullable)
            ColumnType.TIMESTAMP -> timeStampColumn(nullable)
            ColumnType.OFFSET_DATETIME -> offsetDateTimeColumn(nullable)
        }

    fun <T> getColumnForValue(value: T): Column<T> =
        when (value) {
            is Int -> INTEGER
            is Double -> DOUBLE
            is Long -> LONG
            is String -> VARCHAR
            is LocalDateTime -> DATETIME
            is LocalDate -> DATE
            is ZonedDateTime -> OFFSET_DATETIME
            is Boolean -> BOOLEAN
            else -> throw IllegalArgumentException("Type $value not supported for parameter: only Int, Long, Double, Date or String")
        } as Column<T>

    fun <T> forClass(clz: Class<T>): Column<T> {
        return when (clz.simpleName) {
            "boolean" -> BOOLEAN
            "Boolean" -> BOOLEAN
            "byte" -> BYTE
            "Byte" -> BYTE
            "int" -> INTEGER
            "Integer" -> INTEGER
            "long" -> LONG
            "Long" -> LONG
            "double" -> DOUBLE
            "Double" -> DOUBLE
            "float" -> FLOAT
            "Float" -> FLOAT
            "String" -> VARCHAR
            "LocalDate" -> DATE
            "LocalDateTime" -> DATETIME
            "LocalTime" -> TIME
            "OffsetDateTime" -> OFFSET_DATETIME
            else -> throw java.lang.IllegalArgumentException("Could not map class $clz to known Column implementation.")
        } as Column<T>
    }

    fun getForeignKeyColumnForType(column: AnyColumn): AnyColumn =
        when (column) {
            is IntegerColumn -> FOREIGN_KEY_INT
            is NullableIntegerColumn -> FOREIGN_KEY_INT_NIL
            is LongColumn -> FOREIGN_KEY_LONG
            is NullableLongColumn -> FOREIGN_KEY_LONG_NIL
            is VarcharColumn -> FOREIGN_KEY_VARCHAR
            is NullableVarcharColumn -> FOREIGN_KEY_VARCHAR_NIL
            else -> throw IllegalArgumentException("Column type ${column.columnClass.simpleName} cannot be used as a foreign key. It has to be of numeric of character type")
        }

}
