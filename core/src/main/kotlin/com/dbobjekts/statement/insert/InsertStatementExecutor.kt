package com.dbobjekts.statement.insert

import com.dbobjekts.AnyColumnAndValue
import com.dbobjekts.AnySqlParameter
import com.dbobjekts.SQL
import com.dbobjekts.jdbc.ConnectionAdapter
import com.dbobjekts.metadata.Catalog
import com.dbobjekts.metadata.column.AutoKeyColumn
import com.dbobjekts.metadata.column.SequenceKeyColumn
import com.dbobjekts.statement.ColumnsForUpdate
import com.dbobjekts.statement.StatementBase
import com.dbobjekts.util.StringUtil
import com.dbobjekts.vendors.VendorSpecificProperties
import java.lang.IllegalStateException

class InsertStatementExecutor(
    connection: ConnectionAdapter,
    val values: List<AnyColumnAndValue>,
    val vendorSpecificProperties: VendorSpecificProperties
) : StatementBase<Long>(connection) {

    override val catalog: Catalog = connection.catalog()

    protected val columnsForUpdate = ColumnsForUpdate()

    init {
        registerTablesInColumn(values)
    }


    fun parameters(): List<AnySqlParameter> = columnsForUpdate.params.toList()

    fun execute(): Long {
        val pk = getTable().primaryKey()
        return if (pk == null) {
            values.forEach { columnsForUpdate.addParam(it) }
            val sql = toSQL()
            val plh = parameters()
            logger.logStatement(sql, plh)
            connection.prepareAndExecuteUpdate(sql, plh)
        } else {
            when (pk) {
                is SequenceKeyColumn<*> -> {
                    logger.info("Primary keys are generated from sequence ${pk}")
                    val sequenceSql =
                        generateSequencePattern() ?: throw IllegalArgumentException("sequence pattern cannot be empty")
                    val newKeyValue: Long =
                        createKeyFromSequence(connection, String.format(sequenceSql, pk.qualifiedSequence()))
                    columnsForUpdate.addParam(pk.createValueForUpdate(newKeyValue))
                    values.forEach { columnsForUpdate.addParam(it) }
                    val sql = toSQL()
                    connection.prepareAndExecuteUpdate(sql, parameters())
                    newKeyValue
                }
                is AutoKeyColumn<*> -> {
                    logger.info("Primary key is generated by auto-increment.")
                    values.forEach {columnsForUpdate.addParam(it)}
                    connection.executeInsertWithAutoGeneratedKey(toSQL(), parameters())
                }
                else -> throw IllegalStateException("primary key must be SequenceKeyColumn or AutoKeyColumn")
            }
        }
    }

    fun createKeyFromSequence(
        connection: ConnectionAdapter,
        sql: String
    ): Long = connection.fetchKey(SQL(sql)) ?: 0

     fun toSQL(): SQL {
        val columns = columnsForUpdate.getCommaSeparatedColumnList()
        val values = columnsForUpdate.getCommaSeparatedQuestionMarks()
        return SQL(
            StringUtil.concat(
                listOf(
                    "insert into",
                    getTable().schemaAndName(),
                    "($columns)",
                    "values",
                    "($values)"
                )
            )
        )
    }

    fun generateSequencePattern(): String? = vendorSpecificProperties.sequencePattern()

}

