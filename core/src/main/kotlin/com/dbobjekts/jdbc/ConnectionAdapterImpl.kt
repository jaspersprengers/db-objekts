package com.dbobjekts.jdbc

import com.dbobjekts.AnySqlParameter
import com.dbobjekts.SQL
import com.dbobjekts.api.ConnectionAdapter
import com.dbobjekts.metadata.Catalog
import com.dbobjekts.result.ColumnInResultRow
import com.dbobjekts.result.ResultRow
import com.dbobjekts.util.StatementLogger
import com.dbobjekts.vendors.Vendor
import com.dbobjekts.vendors.VendorSpecificProperties
import java.sql.*

data class ConnectionAdapterImpl (
    override val jdbcConnection: Connection,
    val statementLogger: StatementLogger,
    private val _catalog: Catalog?,
    override val vendor: Vendor
) : ConnectionAdapter {

    override fun catalog(): Catalog = _catalog ?: throw IllegalStateException(
        """
          This connection is not associated with an implementation of com.dbobjekts.metadata.Catalog.
          You need to provide this during the initialization in order to build queries.
          """
    )

    fun isValid(): Boolean = !this.jdbcConnection.isClosed && this.jdbcConnection.isValid(2000)

    val vendorSpecificProperties: VendorSpecificProperties = vendor.properties

    fun close() {
        try {
            jdbcConnection.close()
        } catch (e: SQLException) {
            statementLogger.error("Error trying to close connection.", e)
        }
    }

    fun commit() {
        if (!jdbcConnection.isClosed)
            jdbcConnection.commit()
    }

    fun rollback() {
        if (!jdbcConnection.isClosed)
            jdbcConnection.rollback()
    }

    fun prepareAndExecuteUpdate(sql: SQL, parameters: List<AnySqlParameter>): Long {
        val statement = jdbcConnection.prepareStatement(sql.value)
        parameters.forEach { it.setValueOnStatement(statement) }
        statementLogger.logStatement(sql, parameters)
        return statement.executeUpdate().toLong()
    }

    fun <T : ResultRow<*>> prepareAndExecuteForSelect(
        sql: SQL,
        parameters: List<AnySqlParameter>,
        columnsToFetch: List<ColumnInResultRow>,
        selectResultSet: T
    ): T {
        val resultSetAdapter = JDBCResultSetAdapter(columnsToFetch, executeSelect(sql, parameters))
        selectResultSet.initialize(resultSetAdapter)
        selectResultSet.retrieveAll()
        return selectResultSet
    }


    fun <T, RS : ResultRow<T>> prepareAndExecuteForSelectWithRowIterator(
        sql: SQL,
        parameters: List<AnySqlParameter>,
        columnsToFetch: List<ColumnInResultRow>,
        selectResultSet: RS,
        iteratorFunction: (T) -> Boolean
    ) {
        val resultSetAdapter = JDBCResultSetAdapter(columnsToFetch, executeSelect(sql, parameters))
        selectResultSet.initialize(resultSetAdapter)
        resultSetAdapter.retrieveWithIterator(selectResultSet, iteratorFunction)
    }

    private fun executeSelect(
        sql: SQL,
        params: List<AnySqlParameter>
    ): ResultSet {
        val statement = jdbcConnection.prepareStatement(sql.value)
        params.forEach { it.setValueOnStatement(statement) }
        statementLogger.logStatement(sql, params)
        return statement.executeQuery()
    }

    fun prepareAndExecuteDeleteStatement(sql: SQL, parameters: List<AnySqlParameter>): Long {
        statementLogger.logStatement(sql, parameters)
        return prepareAndExecuteUpdate(sql, parameters)
    }

    fun fetchKey(sql: SQL): Long? {
        var stm: PreparedStatement? = null
        try {
            stm = jdbcConnection.prepareStatement(sql.value)
            val rs = stm.executeQuery()
            return if (!rs.next()) {
                statementLogger.error("Could not retrieve value from sequence. Resultset was empty.")
                null
            } else
                rs.getLong(1).let { if (it == 0L) null else it }
        } finally {
            stm?.close()
        }
    }

    fun executeInsertWithAutoGeneratedKey(sql: SQL, parameters: List<AnySqlParameter>): Long {
        val statement = jdbcConnection.prepareStatement(sql.value, Statement.RETURN_GENERATED_KEYS)
        parameters.forEach { it.setValueOnStatement(statement) }
        statement.executeUpdate()
        return getAutoGeneratedKeyFromStatement(statement)
    }

     fun getAutoGeneratedKeyFromStatement(statement: PreparedStatement): Long {
        var genKey: ResultSet? = null
        try {
            genKey = statement.getGeneratedKeys()
            return if (genKey?.next() ?: false) {
                genKey.getLong(1)
            } else {
                throw IllegalStateException("could not retrieve generated key from PreparedStatement")
            }
        } finally {
            genKey?.close()
        }
    }

}
