package com.dbobjekts.codegen

import com.dbobjekts.PackageName
import com.dbobjekts.SchemaName
import com.dbobjekts.TableName
import com.dbobjekts.codegen.configbuilders.CodeGeneratorConfig
import com.dbobjekts.codegen.datatypemapper.ColumnMappingProperties
import com.dbobjekts.codegen.datatypemapper.ColumnTypeResolver
import com.dbobjekts.codegen.metadata.*
import com.dbobjekts.metadata.Columns
import org.slf4j.LoggerFactory

/**
 * Yields a DBTableDefinition
 */
class TableBuilder(
    val packageName: PackageName,
    val schema: SchemaName,
    val tableName: TableName,
    val generatorConfig: CodeGeneratorConfig,
    val foreignKeyManager: ForeignKeyManager,
    val sqlMapper: ColumnTypeResolver
) {
    private val log = LoggerFactory.getLogger(TableBuilder::class.java)
    var alias: String = tableName.value
    val columns: MutableList<DBColumnDefinition> = mutableListOf()

    fun getForeignKeyDefinition(columnMetaData: ColumnMetaData): DBForeignKeyDefinition? =
        foreignKeyManager.findForeignKey(schema, tableName, columnMetaData.columnName)?.let{
            val foreignKey = sqlMapper.getForeignKeyColumnForType(schema, tableName, columnMetaData)
            DBForeignKeyDefinition(
                    table = tableName,
                    columnName = it.col,
                    columnType = foreignKey,
                    parentSchema = it.parentSchema,
                    parentTable = it.parentTable,
                    parentColumn = it.parentColumn,
                    comment = columnMetaData.remarks
                )
        }

    fun findPrimaryKey(props: ColumnMetaData): DBColumnDefinition? {
        val columnMappingProperties = ColumnMappingProperties.fromMetaData(schema, tableName, props)
        return if (!props.isPrimaryKey || !generatorConfig.vendor.properties.columnTypeCanBeAutoGeneratedKey(props.columnType))
            null
        else {
            val defaultType = sqlMapper.getDefaultMapping(columnMappingProperties)
            if (props.isAutoIncrement) {
                    DBAutoGeneratedKeyDefinition(
                        table = tableName,
                        columnName = props.columnName,
                        columnType = Columns.determineAutoGeneratedColumn(defaultType),
                        comment = props.remarks
                    )
            } else {
                when(val strategy = generatorConfig.primaryKeyStrategy) {
                    is SequenceNameResolverStrategy -> strategy.getSequence(columnMappingProperties)
                    else -> null
                }?.let {
                    DBSequenceKeyDefinition(
                    table = tableName,
                    name = props.columnName,
                    columnType = Columns.determineAutoGeneratedColumn(defaultType),
                    sequence = it,
                    comment = props.remarks)
                }
            }
        }
    }

    fun withColumns(
        schema: SchemaName,
        table: TableName,
        columnMetaData: List<ColumnMetaData>
    ): TableBuilder {
        columnMetaData.forEach {  props ->
            findPrimaryKey(props)?.let { pk ->
                log.debug("Adding primary key for ${pk.tableName}.${pk.columnName}")
                addColumn(pk)
            }?:getForeignKeyDefinition(props)?.let {fk ->
                log.debug("Adding foreign key for ${fk.tableName}.${fk.columnName}")
                addColumn(fk)
            }?:sqlMapper.mapDataType(ColumnMappingProperties.fromMetaData(schema, table, props)).let {colType ->
                val column = DBColumnDefinition(tableName, props.columnName, colType, props.remarks)
                addColumn(column)
            }
        }
        return this
    }


    fun addColumn(columnDef: DBColumnDefinition) {
        columns += columnDef
    }

    fun withAlias(alias: String): TableBuilder {
        this.alias = alias
        return this
    }

    fun build(): DBTableDefinition = DBTableDefinition(packageName, schema, tableName, alias, columns)

}
