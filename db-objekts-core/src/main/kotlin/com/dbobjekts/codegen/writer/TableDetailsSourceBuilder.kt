package com.dbobjekts.codegen.writer

import com.dbobjekts.api.WriteQueryAccessors
import com.dbobjekts.codegen.metadata.*
import com.dbobjekts.codegen.metadata.DBGeneratedPrimaryKey
import com.dbobjekts.metadata.column.NullableColumn
import com.dbobjekts.statement.insert.InsertBuilderBase
import com.dbobjekts.statement.update.UpdateBuilderBase
import com.dbobjekts.util.StringUtil

data class FieldData(
    val field: String,
    val columnName: String,
    val fieldType: String,
    val defaultClause: String,
    val nullable: Boolean,
    val autoGenPK: Boolean,
    val regularPK: Boolean
)

class TableDetailsSourceBuilder(val tableDefinition: DBTableDefinition) {

    private val tableName = tableDefinition.asClassName()

    val fields: List<FieldData>
    val allFieldsExceptAutoPK: List<FieldData>
    val nonNullFields: List<FieldData>
    val primaryKey: FieldData?
    val autoPrimaryKey: FieldData?

    init {
        fields = tableDefinition.columns.map { colDef ->
            val fieldName =
                ReservedKeywords.prependIfReserved(StringUtil.snakeToCamel(colDef.columnName.value.lowercase()))
            val isNullable = colDef.column is NullableColumn<*>
            val dataType = StringUtil.classToString(colDef.column.valueClass) + (if (isNullable) "?" else "")
            val defaultClause: String = getDefaultValue(colDef)?.let { " = $it" } ?: ""
            val autoGenPk = colDef is DBGeneratedPrimaryKey
            FieldData(fieldName, colDef.columnName.value, dataType, defaultClause, isNullable, autoGenPk, colDef.isPrimaryKey)
        }
        allFieldsExceptAutoPK = fields.filterNot { it.autoGenPK }
        nonNullFields = allFieldsExceptAutoPK.filterNot { it.nullable || it.autoGenPK }
        primaryKey = fields.filter { it.regularPK || it.autoGenPK }.firstOrNull()
        autoPrimaryKey = fields.filter { it.autoGenPK }.firstOrNull()
    }

    fun sourceForTableComment(): String {
        val fks =
            tableDefinition.columns.filter { it is DBForeignKeyDefinition }.map { it as DBForeignKeyDefinition }
                .map { "${it.columnName.value} to ${it.parentSchema.value}.${it.parentTable.value}.${it.parentColumn.value}" }
        val composite = tableDefinition.columns.filter { it.isCompositePrimaryKey }
        val pks = if (composite.isEmpty()) (primaryKey?.columnName ?: "none") else composite.map { it.columnName.value }
        return """
            /**           
             * Auto-generated metadata object for db table ${tableDefinition.schema.value}.${tableDefinition.tableName}.
             *
             * Do not edit this file manually! Always use [com.dbobjekts.codegen.CodeGenerator] when the metadata model is no longer in sync with the database.           
             *
             * Primary keys: $pks
             *
             * Foreign keys: $fks 
             */
        """.trimIndent()
    }

    fun sourceForToValue(): String {
        val elements = fields.mapIndexed { i, field ->
            "values[$i] as ${field.fieldType}"
        }.joinToString(",")
        return "    override fun toValue(values: List<Any?>) = ${tableName}Row($elements)"
    }

    fun sourceForUpdateRowMethod(): String {
        if (primaryKey == null)
            return """
    /**
     * Warning: this method will throw a StatementBuilderException at runtime because $tableName does not have a primary key, or has a composite one.
     */
    override fun updateRow(rowData: TableRowData<*, *>): Long = 
      throw StatementBuilderException("Sorry, but you cannot use row-based updates for table ${tableName}. There must be exactly one column marked as primary key.")                
            """

        val elements = fields.mapIndexed { _, field ->
            "      add($tableName.${field.field}, rowData.${field.field})"
        }.joinToString("\n")
        val pkCol = primaryKey.field
        val source = """    
    /**
     * FOR INTERNAL USE ONLY
     */
    override fun updateRow(rowData: TableRowData<*, *>): Long {
      rowData as ${tableName}Row
$elements
      return where (${tableName}.$pkCol.eq(rowData.$pkCol))
    }    
        """
        return source
    }

    fun sourceForRowDataClass(): String {
        val elements = mutableListOf<String>()
        if (autoPrimaryKey != null)
            elements += "val ${autoPrimaryKey.field}: ${autoPrimaryKey.fieldType} = 0"

        elements.addAll(allFieldsExceptAutoPK.map { f ->
            "  val ${f.field}: ${f.fieldType}"
        })
        val fieldStr = elements.joinToString(",\n")
        val source = """
data class ${tableName}Row(
$fieldStr    
) : TableRowData<${tableName}UpdateBuilder, ${tableName}InsertBuilder>(${tableName}.metadata())
        """
        return source
    }

    private fun sourceForInsertRowMethod(): String {
        val elements = allFieldsExceptAutoPK.mapIndexed { _, field ->
            "      add($tableName.${field.field}, rowData.${field.field})"
        }.joinToString("\n")
        val source = """
    override fun insertRow(rowData: TableRowData<*, *>): Long {
      rowData as ${tableName}Row
$elements
      return execute()
    }    
        """
        return source
    }

    private fun sourceForMandatoryColumnsMethod(): String {
        return if (nonNullFields.isEmpty()) "" else
            """
    fun mandatoryColumns(${nonNullFields.map { f -> "${f.field}: ${f.fieldType}" }.joinToString(", ")}) : ${tableName}InsertBuilder {
${nonNullFields.map { f -> "      mandatory($tableName.${f.field}, ${f.field})" }.joinToString("\n")}
      return this
    }
"""
    }

    fun sourceForMetaDataVal(): String {
        val accessorClass = WriteQueryAccessors::class.java.simpleName
        val updateBuilder = "${tableName}UpdateBuilder"
        val insertBuilder = "${tableName}InsertBuilder"
        return "    override fun metadata(): $accessorClass<$updateBuilder, $insertBuilder> = $accessorClass($updateBuilder(), $insertBuilder())"
    }

    fun sourceForBuilderClasses(): String {
        val updateBuilderBase = UpdateBuilderBase::class.java.simpleName
        val insertBuilderBase = InsertBuilderBase::class.java.simpleName

        fun writeMethod(data: FieldData, returnType: String) =
            "    fun ${data.field}(value: ${data.fieldType}): $returnType = put($tableName.${data.field}, value)"

        val updateRowMethodSource = sourceForUpdateRowMethod()
        val insertRowMethodSource = sourceForInsertRowMethod()
        val mandatoryColumnsMethod = sourceForMandatoryColumnsMethod()

        val updateBuilder = "${tableName}UpdateBuilder"
        val insertBuilder = "${tableName}InsertBuilder"

        return """
class $updateBuilder() : $updateBuilderBase($tableName) {
${allFieldsExceptAutoPK.map { d -> writeMethod(d, updateBuilder) }.joinToString("\n")}
$updateRowMethodSource
}

class $insertBuilder():$insertBuilderBase(){
${allFieldsExceptAutoPK.map { d -> writeMethod(d, insertBuilder) }.joinToString("\n")}
$mandatoryColumnsMethod
$insertRowMethodSource
}
"""
    }


    private fun getDefaultValue(colDef: DBColumnDefinition): String? {
        if (!(colDef.column is NullableColumn<*>))
            return null
        val clz = colDef.column.valueClass
        return if (!clz.isPrimitive) "null"
        else {
            when (clz.simpleName) {
                "byte" -> "0"
                "short" -> "0"
                "int" -> "0"
                "float" -> "0f"
                "long" -> "0l"
                "double" -> "0d"
                "boolean" -> "false"
                else -> null
            }
        }
    }


}
