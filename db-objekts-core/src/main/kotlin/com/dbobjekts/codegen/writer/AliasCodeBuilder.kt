package com.dbobjekts.codegen.writer

import com.dbobjekts.codegen.metadata.DBCatalogDefinition
import com.dbobjekts.metadata.SchemaAndTable
import com.dbobjekts.metadata.TableAliasesBuilder

class AliasCodeBuilder(val catalog: DBCatalogDefinition) {
  private val strBuilder = StringBuilder()

  fun createFileSource(): String {

    strBuilder.append("package ${catalog.packageName}\n")

    catalog.schemas.flatMap {it.tables} .forEach { strBuilder.append("import ${it.fullyQualifiedClassName()}\n") }

    strBuilder.append(createObjectBody())
    return strBuilder.toString()
  }

  fun createObjectBody(): String {
    val schemaAndTables: List<SchemaAndTable> = catalog.schemas.flatMap { schema -> schema.tables.map { SchemaAndTable(schema.schemaName, it.tableName) } }

    val builder = TableAliasesBuilder()
    builder.add(schemaAndTables)
    val aliases = builder.build()

    val lines = schemaAndTables.map {st -> "    val ${aliases.aliasForSchemaAndTable(st)} = ${st.table.capitalCamelCase()}" }


      return """
/**  
 * Auto-generated metadata object. Provides a list of unique aliases for each table across all schemas in the catalog. These are used in the SQL that db-Objekts generates.
 *
 * Do not edit this file manually! Always use [com.dbobjekts.codegen.CodeGenerator] when the metadata model is no longer in sync with the database.
 *
 * You can import the individual values of in this object in your code to use them as convenient shortcuts.
 *
 * ```
 * import ${catalog.packageName}.Aliases.e
 * [...]
 * transaction.select(e.name)
 *```
 */        
object Aliases {
${lines.joinToString("\n")}
}
     """

  }

}
